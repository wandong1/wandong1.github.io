<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on 万东的云计算运维博客</title>
    <link>https://wandong1.github.io/post/</link>
    <description>Recent content in Posts on 万东的云计算运维博客</description>
    <image>
      <url>https://wandong1.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://wandong1.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 15 Sep 2022 08:15:16 +0000</lastBuildDate><atom:link href="https://wandong1.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>hexo博客框架的使用</title>
      <link>https://wandong1.github.io/post/hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Thu, 15 Sep 2022 08:15:16 +0000</pubDate>
      
      <guid>https://wandong1.github.io/post/hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>hexo博客框架的使用 安装node.js 官网： https://nodejs.org/en/
安装国内淘宝npm npm install -g cnpm --registry=https://registry.npm.taobao.org 安装hexo cnpm install -g hexo-clihexo -v hexo初始化 hexo init 目录 hexo server 新建文章 文章都在source\_posts目录下
hexo new &amp;#34;我的第一篇博客文章&amp;#34; 配置后刷新并重启服务 hexo clean hexo g hexo server 更换主题 进入项目目录
git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 修改项目目录下配置文件_config.yml
theme: yilia 修复更换主题后全部文章无法显示问题 # 进入项目目录后 cnpm i hexo-generator-json-content --save # 随后在项目目录下的_config.yml文件后添加内容 jsonContent: meta: false pages: false posts: title: true date: true path: true text: false raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true 刷新并重启项目</description>
    </item>
    
    <item>
      <title>http常见状态码</title>
      <link>https://wandong1.github.io/post/http%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81/</link>
      <pubDate>Thu, 15 Sep 2022 08:15:16 +0000</pubDate>
      
      <guid>https://wandong1.github.io/post/http%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81/</guid>
      <description>各类别常见状态码：
2xx （3种） 200 OK：表示从客户端发送给服务器的请求被正常处理并返回；
204 No Content：表示客户端发送给客户端的请求得到了成功处理，但在返回的响应报文中不含实体的主体部分（没有资源可以返回）；
206 Patial Content：表示客户端进行了范围请求，并且服务器成功执行了这部分的GET请求，响应报文中包含由Content-Range指定范围的实体内容。
3xx （5种） 301 Moved Permanently：永久性重定向，表示请求的资源被分配了新的URL，之后应使用更改的URL；
302 Found：临时性重定向，表示请求的资源被分配了新的URL，希望本次访问使用新的URL；
301与302的区别：前者是永久移动，后者是临时移动（之后可能还会更改URL）
303 See Other：表示请求的资源被分配了新的URL，应使用GET方法定向获取请求的资源；
302与303的区别：后者明确表示客户端应当采用GET方式获取资源 304 Not Modified：表示客户端发送附带条件（是指采用GET方法的请求报文中包含if-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since中任一首部）的请求时，服务器端允许访问资源，但是请求为满足条件的情况下返回改状态码；
307 Temporary Redirect：临时重定向，与303有着相同的含义，307会遵照浏览器标准不会从POST变成GET；（不同浏览器可能会出现不同的情况）；
4xx （4种） 400 Bad Request：表示请求报文中存在语法错误；
401 Unauthorized：未经许可，需要通过HTTP认证；
403 Forbidden：服务器拒绝该次访问（访问权限出现问题）
404 Not Found：表示服务器上无法找到请求的资源，除此之外，也可以在服务器拒绝请求但不想给拒绝原因时使用；
429 当你需要限制客户端请求某个服务的数量，也就是限制请求速度时，该状态码就会非常有用。
5xx （2种） 500 Inter Server Error：表示服务器在执行请求时发生了错误，也有可能是web应用存在的bug或某些临时的错误时；
502 bad gateway 503 Server Unavailable：表示服务器暂时处于超负载或正在进行停机维护，无法处理请求；</description>
    </item>
    
    <item>
      <title>Hugo 博客程序搭建教程</title>
      <link>https://wandong1.github.io/post/hugo-%E5%8D%9A%E5%AE%A2%E7%A8%8B%E5%BA%8F%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/</link>
      <pubDate>Thu, 15 Sep 2022 08:15:16 +0000</pubDate>
      
      <guid>https://wandong1.github.io/post/hugo-%E5%8D%9A%E5%AE%A2%E7%A8%8B%E5%BA%8F%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/</guid>
      <description>下载hugo二进制程序包 下载地址： https://github.com/gohugoio/hugo/releases
下载后解压、将hugo路径添加到环境变量。先设置hugo变量，然后在path中添加
验证安装 hugo version 新建站点 hugo new site myblog # 该命令会新建一个文件夹myblog ls ./myblog # archetypes/ config.toml content/ data/ # layouts/ static/ themes/ ##我目前了解如下 #config.toml 进行参数配置，与之后的theme相关 #content 之后博客(.md)的文件都储存在这里 #layout 可个性化修改博客的展示细节，需要懂网络架构知识 #static 储存一些静态文件，比如本地图片，插入到博客中 #themes 主题，接下来会介绍 下载主题（hugo没有默认主题） 有多种hugo主题可供下载：https://themes.gohugo.io/ 推荐主题： https://adityatelange.github.io/hugo-PaperMod/
cd ./myblog git clone https://github.com/adityatelange/hugo-PaperMod themes/PaperMod ls ./themes # PaperMod/ ls ./themes/PaperMod/ # LICENSE README.md assets/ go.mod i18n/ images/ layouts/ theme.toml 修改配置 papermod
通用配置参数查询：https://gohugo.io/getting-started/configuration/
PaperMod自定义参数查询：https://adityatelange.github.io/hugo-PaperMod/posts/papermod/papermod-features/
示例配置：https://www.sulvblog.cn/posts/blog/build_hugo/#4%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6
将 config.toml 重命名为 config.yml 然后进行修改</description>
    </item>
    
    <item>
      <title>K8S根据现有证书生成管理员kubeconfig文件</title>
      <link>https://wandong1.github.io/post/k8s%E6%A0%B9%E6%8D%AE%E7%8E%B0%E6%9C%89%E8%AF%81%E4%B9%A6%E7%94%9F%E6%88%90%E7%AE%A1%E7%90%86%E5%91%98kubeconfig%E6%96%87%E4%BB%B6/</link>
      <pubDate>Thu, 15 Sep 2022 08:15:16 +0000</pubDate>
      
      <guid>https://wandong1.github.io/post/k8s%E6%A0%B9%E6%8D%AE%E7%8E%B0%E6%9C%89%E8%AF%81%E4%B9%A6%E7%94%9F%E6%88%90%E7%AE%A1%E7%90%86%E5%91%98kubeconfig%E6%96%87%E4%BB%B6/</guid>
      <description>生成管理员证书 cat &amp;gt; admin-csr.json &amp;lt;&amp;lt;EOF { &amp;#34;CN&amp;#34;: &amp;#34;admin&amp;#34;, &amp;#34;hosts&amp;#34;: [], &amp;#34;key&amp;#34;: { &amp;#34;algo&amp;#34;: &amp;#34;rsa&amp;#34;, &amp;#34;size&amp;#34;: 2048 }, &amp;#34;names&amp;#34;: [ { &amp;#34;C&amp;#34;: &amp;#34;CN&amp;#34;, &amp;#34;L&amp;#34;: &amp;#34;BeiJing&amp;#34;, &amp;#34;ST&amp;#34;: &amp;#34;BeiJing&amp;#34;, &amp;#34;O&amp;#34;: &amp;#34;system:masters&amp;#34;, &amp;#34;OU&amp;#34;: &amp;#34;System&amp;#34; } ] } EOF 执行生成命令 cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes admin-csr.json | cfssljson -bare admin 创建kubeconfig文件 # 设置集群参数 kubectl config set-cluster kubernetes \ --server=https://192.168.0.149:6443 \ --certificate-authority=ca.pem \ --embed-certs=true \ --kubeconfig=config # 设置上下文参数 kubectl config set-context default \ --cluster=kubernetes \ --user=cluster-admin \ --kubeconfig=config # 设置客户端认证参数 kubectl config set-credentials cluster-admin \ --certificate-authority=ca.</description>
    </item>
    
    <item>
      <title>mongodb的安装部署</title>
      <link>https://wandong1.github.io/post/mongodb%E7%9A%84%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/</link>
      <pubDate>Thu, 15 Sep 2022 08:15:16 +0000</pubDate>
      
      <guid>https://wandong1.github.io/post/mongodb%E7%9A%84%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/</guid>
      <description>软件包下载 https://www.mongodb.com/try/download/community wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-5.0.8.tgz mongodb模式介绍 三节点复制集模式 常见的复制集架构由3个成员节点组成，其中存在几种不同的模式。 PSS模式（官方推荐模式） PSS模式由一个主节点和两个备节点所组成，即Primary+Secondary+Secondary。 此模式始终提供数据集的两个完整副本，如果主节点不可用，则复制集选择备节点作为主节 点并继续正常操作。旧的主节点在可用时重新加入复制集。 复制集部署注意事项 关于硬件: 因为正常的复制集节点都有可能成为主节点，它们的地位是一样的，因此硬件配 置上必须一致; 为了保证节点不会同时宕机，各节点使用的硬件必须具有独立性。
关于软件: 复制集各节点软件版本必须一致，以避免出现不可预知的问题。 增加节点不会增加系统写性能；
准备配置文件 复制集的每个mongod进程应该位于不同的服务器。我们现在在一台机器上运行3个进程， 因此要为它们各自配置：
不同的端口 （28017/28018/28019）
不同的数据目录 mkdir ‐p /data/db{1,2,3} 不同日志文件路径 (例如：/data/db1/mongod.log)
创建配置文件/data/db1/mongod.conf，内容如下：
systemLog: destination: file path: /data/db1/mongod.log logAppend: true storage: dbPath: /data/db1 net: bindIp: 0.0.0.0 port: 28017 replication: replSetName: rs0 processManagement: fork: true 创建配置文件/data/db2/mongod.conf，内容如下：
systemLog: destination: file path: /data/db2/mongod.log logAppend: true storage: dbPath: /data/db2 net: bindIp: 0.0.0.0 port: 28018 replication: replSetName: rs0 processManagement: fork: true 创建配置文件/data/db3/mongod.</description>
    </item>
    
    <item>
      <title>navicat15部署</title>
      <link>https://wandong1.github.io/post/navicat15%E9%83%A8%E7%BD%B2/</link>
      <pubDate>Thu, 15 Sep 2022 08:15:16 +0000</pubDate>
      
      <guid>https://wandong1.github.io/post/navicat15%E9%83%A8%E7%BD%B2/</guid>
      <description>参考地址：https://www.bilibili.com/read/cv15128680</description>
    </item>
    
    <item>
      <title>nginx的四层转发和七层转发配置示例</title>
      <link>https://wandong1.github.io/post/nginx%E7%9A%84%E5%9B%9B%E5%B1%82%E8%BD%AC%E5%8F%91%E5%92%8C%E4%B8%83%E5%B1%82%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B/</link>
      <pubDate>Thu, 15 Sep 2022 08:15:16 +0000</pubDate>
      
      <guid>https://wandong1.github.io/post/nginx%E7%9A%84%E5%9B%9B%E5%B1%82%E8%BD%AC%E5%8F%91%E5%92%8C%E4%B8%83%E5%B1%82%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B/</guid>
      <description>user nginx; worker_processes auto; error_log /var/log/nginx/error.log notice; pid /var/run/nginx.pid; events { worker_connections 1024; } # 4层 stream配置 stream { log_format main &amp;#39;$remote_addr $upstream_addr - [$time_local] $status $upstream_bytes_sent&amp;#39;; access_log /var/log/nginx/dingding-access.log main; upstream dingding { server oapi.dingtalk.com:80; } upstream dingding_v2 { server oapi.dingtalk.com:443; } upstream apsoar { server soar.apsoar.com:22; } upstream timor { server timor.tech:443; } upstream timor80 { server timor.tech:80; } server { listen 22; proxy_pass apsoar; } server { listen 7003; proxy_pass timor80; } server { listen 80; proxy_pass dingding; } server { listen 443; proxy_pass dingding_v2; } } # 7层http配置 http { include /etc/nginx/mime.</description>
    </item>
    
    <item>
      <title>nginx调优方法</title>
      <link>https://wandong1.github.io/post/nginx%E8%B0%83%E4%BC%98%E6%96%B9%E6%B3%95/</link>
      <pubDate>Thu, 15 Sep 2022 08:15:16 +0000</pubDate>
      
      <guid>https://wandong1.github.io/post/nginx%E8%B0%83%E4%BC%98%E6%96%B9%E6%B3%95/</guid>
      <description>一、优化nginx进程数以及cpu分布 修改配置文件 worker_processes 8; worker_cpu_affinity 00000001 00000010 00000100 00001000 00010000 00100000 01000000 10000000; 几核就有几位二进制数，1在哪位就表示在哪个核心上。
查看nginx worker进程分布在cpu的情况 ps -axo pid,psr,cmd,ni | grep -i &amp;#34;worker process&amp;#34; | awk &amp;#39;{print $2}&amp;#39; | sort -n | uniq -c 二、优化文件数
ulimit -n #查看文件数限制 ulimit -SHn 65535 （注ulimit -SHn 65535 等效 ulimit -n 65535，-S指soft，-H指hard) #有如下三种修改方式： 1.在/etc/rc.local 中增加一行 ulimit -SHn 65535 2.在/etc/profile 中增加一行 ulimit -SHn 65535 3.在/etc/security/limits.conf最后增加如下两行记录 * soft nofile 65535 * hard nofile 65535 nginx配置修改：
worker_rlimit_nofile 65535; 三、使用epoll的I/O模型，用这个模型来高效处理异步事件 在events区块中添加 use epoll; 四、每个进程允许的最多连接数，理论上每台nginx服务器的最大连接数为 # worker_processes*worker_connections。为理论上最大连接数 在events区块中添加或修改 worker_connections 65535; 五、http连接超时时间 默认是60s，功能是使客户端到服务器端的连接在设定的时间内持续有效，当出现对服务器的后继请求时，该功能避免了建立或者重新建立连接。切记这个参数也不能设置过大！否则会导致许多无效的http连接占据着nginx的连接数，终nginx崩溃！</description>
    </item>
    
    <item>
      <title>prometheus直接安装</title>
      <link>https://wandong1.github.io/post/prometheus%E7%9B%B4%E6%8E%A5%E5%AE%89%E8%A3%85/</link>
      <pubDate>Thu, 15 Sep 2022 08:15:16 +0000</pubDate>
      
      <guid>https://wandong1.github.io/post/prometheus%E7%9B%B4%E6%8E%A5%E5%AE%89%E8%A3%85/</guid>
      <description>一、prometheus监控 https://prometheus.io/download/ ###下载源码解压即可 https://grafana.com/grafana/dashboards ###搜索数据源为prometheus的
安装docker mkdir /etc/yum.repos.d/back mv /etc/yum.repos.d/* /etc/yum.repos.d/back wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo yum install -y yum-utils yum-config-manager \ --add-repo \ http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo yum install -y docker-ce systemctl enable docker --now 安装grafana wget https://s3-us-west-2.amazonaws.com/grafana-releases/release/grafana-5.3.4-1.x86_64.rpm yum localinstall grafana-5.3.4-1.x86_64.rpm systemctl start grafana-server 默认密码 admin/admin prometheus安装 tar -xvzf prometheus-2.34.0.linux-amd64.tar.gz -C /opt/ mv /opt/prometheus-2.34.0.linux-amd64 /opt/prometheus cd /opt/prometheus &amp;amp;&amp;amp; mkdir data # 创建启动脚本 cat &amp;lt;&amp;lt;EOF &amp;gt;start.sh #!/bin/bash ./prometheus --storage.tsdb.path=./data --storage.tsdb.retention.time=744h --web.enable-lifecycle --storage.tsdb.no-lockfile EOF # storage.</description>
    </item>
    
    <item>
      <title>rainbond对接nfs或者nas存储</title>
      <link>https://wandong1.github.io/post/rainbond%E5%AF%B9%E6%8E%A5nfs%E6%88%96%E8%80%85nas%E5%AD%98%E5%82%A8/</link>
      <pubDate>Thu, 15 Sep 2022 08:15:16 +0000</pubDate>
      
      <guid>https://wandong1.github.io/post/rainbond%E5%AF%B9%E6%8E%A5nfs%E6%88%96%E8%80%85nas%E5%AD%98%E5%82%A8/</guid>
      <description>https://www.rainbond.com/docs/ops-guide/storage/deploy-nfsclient
添加helm仓库 helm repo add rainbond https://openchart.goodrain.com/goodrain/rainbond helm repo update nfs或者nas配置文件 nfs-client.yaml
nfs: server: 1afc54bbca-jna4.cn-chongqing-cqzwy-d01.nas.alinetops.cqzwy.com #nfs server地址 path: / #nfs server 的路径 mountOptions: #添加参数 - hard - vers=4 - nolock - proto=tcp - rsize=1048576 - wsize=1048576 - timeo=600 - retrans=2 - noresvport 部署 helm install nfs-client-provisioner rainbond/nfs-client-provisioner \ -f nfs-client.yaml \ --version 1.2.8 创建有状态应用进行绑定 </description>
    </item>
    
    <item>
      <title>rainbond平台部署ES-filebeat</title>
      <link>https://wandong1.github.io/post/rainbond%E5%B9%B3%E5%8F%B0%E9%83%A8%E7%BD%B2es-filebeat/</link>
      <pubDate>Thu, 15 Sep 2022 08:15:16 +0000</pubDate>
      
      <guid>https://wandong1.github.io/post/rainbond%E5%B9%B3%E5%8F%B0%E9%83%A8%E7%BD%B2es-filebeat/</guid>
      <description>https://lequ7.com/guan-yu-paas-ping-tai-rainbond-tong-guo-cha-jian-zheng-he-elkefk-shi-xian-ri-zhi-shou-ji.html
通过helm部署filebeat采集容器日志 helm repo add elastic https://helm.elastic.co helm pull elastic/filebeat tar -xvzf filebeat-7.17.3.tgz &amp;amp;&amp;amp; cd filebeat hosts: [&amp;#39;cqzwy-mgmt-log-platform-grc055ce-0.cqzwy-mgmt-log-platform-grc055ce.013497775a1b4580924a00009a20c887.svc.cluster.local:9200&amp;#39;] username: &amp;#34;elastic&amp;#34; password: &amp;#34;kuGmFNENeZyYuGkYZ4BU&amp;#34; 进入容器内ping es的svc即可获得svc全称
helm install filebeat -n 013497775a1b4580924a00009a20c887 ./filebeat helm list -A 或者使用yaml直接不部署
--- apiVersion: v1 kind: ConfigMap metadata: name: filebeat-config namespace: 013497775a1b4580924a00009a20c887 labels: k8s-app: filebeat data: filebeat.yml: |- filebeat.config: inputs: # Mounted `filebeat-inputs` configmap: path: ${path.config}/inputs.d/*.yml # Reload inputs configs as they change: reload.enabled: false modules: path: ${path.config}/modules.d/*.yml # Reload module configs as they change: reload.</description>
    </item>
    
    <item>
      <title>rancher的安装和使用</title>
      <link>https://wandong1.github.io/post/rancher/</link>
      <pubDate>Thu, 15 Sep 2022 08:15:16 +0000</pubDate>
      
      <guid>https://wandong1.github.io/post/rancher/</guid>
      <description>Rancher Rancher 是一套容器管理平台，它可以帮助组织在生产环境中轻松快捷的部署和管理容器。 Rancher 可以轻松地管理各种环境的 Kubernetes，满足 IT 需求并为 DevOps 团队提供支持。
Rancher 四个组成部分 Rancher 由以下四个部分组成：
1、基础设施编排
Rancher 可以使用任何公有云或者私有云的 Linux 主机资源。Linux 主机可以是虚拟机，也可以是 物理机。
2、容器编排与调度
很多用户都会选择使用容器编排调度框架来运行容器化应用。Rancher 包含了当前全部主流的编排 调度引擎，例如 Docker Swarm， Kubernetes， 和 Mesos。同一个用户可以创建 Swarm 或者 Kubernetes 集群。并且可以使用原生的 Swarm 或者 Kubernetes 工具管理应用。 除了 Swarm，Kubernetes 和 Mesos 之外，Rancher 还支持自己的 Cattle 容器编排调度引擎。 Cattle 被广泛用于编排 Rancher 自己的基础设施服务以及用于 Swarm 集群，Kubernetes 集群和 Mesos 集群的配置，管理与升级。
3、应用商店
Rancher 的用户可以在应用商店里一键部署由多个容器组成的应用。用户可以管理这个部署的应 用，并且可以在这个应用有新的可用版本时进行自动化的升级。Rancher 提供了一个由 Rancher 社区维 护的应用商店，其中包括了一系列的流行应用。Rancher 的用户也可以创建自己的私有应用商店。
4、企业级权限管理
Rancher 支持灵活的插件式的用户认证。支持 Active Directory，LDAP， Github 等 认证方 式。</description>
    </item>
    
    <item>
      <title>redis的常见问题</title>
      <link>https://wandong1.github.io/post/redis%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</link>
      <pubDate>Thu, 15 Sep 2022 08:15:16 +0000</pubDate>
      
      <guid>https://wandong1.github.io/post/redis%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</guid>
      <description>1、缓存击穿，某些场景下，大量的key同时失效，请求直接穿过redis缓存层打到数据库上。 解决方法：对key的失效时间设置随机值避免同时失效。
2、缓存穿透，请求进来请求本就不存在的数据，redis层找不到数据库也找不到，每个这种请求都会打到数据库造成压力。 解决方法：对请求的后端数据库不存在的数据，设置空缓存，避免恶意请求对后端数据库造成压力。
3、雪崩，指流量进来打到redis，redis由于某些原因扛不住，流量又会打到数据库，数据库很显然更抗不住。造成系统雪崩。 解决方法：redis采用高可用的集群架构，针对某些bigkey进行打散操作。
4、redis常见数据类型。 string，hash，list，set ，有序set。
5、Redis有哪些适合的场景? (1)Session共享(单点登录);(2)页面缓存;(3)队列;(4)排行榜/计数器;(5)发布/订阅;
(1)LUA脚本：在事务的基础上，假如，需要在服务端一次性的执行更复杂的操作，那么，这个时候lua就可以上场了。</description>
    </item>
    
    <item>
      <title>zookeeper的安装和使用</title>
      <link>https://wandong1.github.io/post/zookeeper/</link>
      <pubDate>Thu, 15 Sep 2022 08:15:16 +0000</pubDate>
      
      <guid>https://wandong1.github.io/post/zookeeper/</guid>
      <description>zookeeper 官网 https://zookeeper.apache.org/ 找download
一、下载软件包 https://dlcdn.apache.org/zookeeper/zookeeper-3.8.0/apache-zookeeper-3.8.0-bin.tar.gz
二、集群部署 1、安装JDK centos
yum install java-1.8.0-openjdk* -y 2、zk配置文件 # The number of milliseconds of each ticktickTime=2000# The number of ticks that the initial # synchronization phase can takeinitLimit=10# The number of ticks that can pass between # sending a request and getting an acknowledgementsyncLimit=5# the directory where the snapshot is stored.# do not use /tmp for storage, /tmp here is just # example sakes.</description>
    </item>
    
    <item>
      <title>helm的使用方法介绍</title>
      <link>https://wandong1.github.io/post/helm%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>Wed, 14 Sep 2022 16:14:24 +0000</pubDate>
      
      <guid>https://wandong1.github.io/post/helm%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</guid>
      <description>Helm Helm是一个Kubernetes的包管理工具，就像Linux下的包管理器，如yum/apt等，可以很方便的将之前
打包好的yaml文件部署到kubernetes上。
Helm有3个重要概念：
• **helm：**一个命令行客户端工具，主要用于Kubernetes应用chart的创建、打包、发布和管理。
• **Chart：**应用描述，一系列用于描述 k8s 资源相关文件的集合。
• **Release：**基于Chart的部署实体，一个 chart 被 Helm 运行后将会生成对应的一个 release；将在
k8s中创建出真实运行的资源对象。
Helm客户端 使用helm很简单，你只需要下载一个二进制客户端包即可，会通过kubeconfig配置（通常$HOME/.kube/config）来连接Kubernetes。
项目地址：https://github.com/helm/helm
下载Helm客户端：
wget https://get.helm.sh/helm-v3.4.2-linux-amd64.tar.gz tar zxvf helm-v3.4.2-linux-amd64.tar.gz mv linux-amd64/helm /usr/bin/ Helm常用命令 Helm管理应用生命周期： • helm create 创建Chart示例
• helm install 部署
• helm upgrade 更新
• helm rollback 回滚
• helm uninstall 卸载
Helm基本使用：创建Chart示例 创建chart：
# 默认示例中部署的是一个nginx服务 helm create mychart 打包chart：
helm package mychart • charts：目录里存放这个chart依赖的所有子chart。
• Chart.yaml：用于描述这个 Chart的基本信息，包括名字、描述信息以及版本等。
• values.yaml ：用于存储 templates 目录中模板文件中用到变量的值。</description>
    </item>
    
    <item>
      <title>Golang学习笔记</title>
      <link>https://wandong1.github.io/post/golang/</link>
      <pubDate>Mon, 15 Aug 2022 08:15:16 +0000</pubDate>
      
      <guid>https://wandong1.github.io/post/golang/</guid>
      <description>Golang学习笔记</description>
    </item>
    
    <item>
      <title>golang定时任务系统</title>
      <link>https://wandong1.github.io/post/golang%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Mon, 15 Aug 2022 08:15:16 +0000</pubDate>
      
      <guid>https://wandong1.github.io/post/golang%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F/</guid>
      <description>golang定时任务系统</description>
    </item>
    
    <item>
      <title>golang微服务</title>
      <link>https://wandong1.github.io/post/golang%E5%BE%AE%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Mon, 15 Aug 2022 08:15:16 +0000</pubDate>
      
      <guid>https://wandong1.github.io/post/golang%E5%BE%AE%E6%9C%8D%E5%8A%A1/</guid>
      <description>golang微服务</description>
    </item>
    
    <item>
      <title>golang日志框架zap</title>
      <link>https://wandong1.github.io/post/golang%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6zap/</link>
      <pubDate>Mon, 15 Aug 2022 08:15:16 +0000</pubDate>
      
      <guid>https://wandong1.github.io/post/golang%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6zap/</guid>
      <description>golang日志框架zap</description>
    </item>
    
    <item>
      <title>jdk安装教程（容器）</title>
      <link>https://wandong1.github.io/post/jdk%E5%AE%89%E8%A3%85/</link>
      <pubDate>Mon, 15 Aug 2022 08:15:16 +0000</pubDate>
      
      <guid>https://wandong1.github.io/post/jdk%E5%AE%89%E8%A3%85/</guid>
      <description>jdk安装教程</description>
    </item>
    
    <item>
      <title>jenkins构建go项目</title>
      <link>https://wandong1.github.io/post/jenkins%E6%9E%84%E5%BB%BAgo%E9%A1%B9%E7%9B%AE/</link>
      <pubDate>Mon, 15 Aug 2022 08:15:16 +0000</pubDate>
      
      <guid>https://wandong1.github.io/post/jenkins%E6%9E%84%E5%BB%BAgo%E9%A1%B9%E7%9B%AE/</guid>
      <description>jenkins构建go项目</description>
    </item>
    
    <item>
      <title>为K8S集群添加nfs类型的sotrageClass</title>
      <link>https://wandong1.github.io/post/%E4%B8%BAk8s%E9%9B%86%E7%BE%A4%E6%B7%BB%E5%8A%A0nfs%E7%B1%BB%E5%9E%8B%E7%9A%84sotrageclass/</link>
      <pubDate>Sun, 15 Aug 2021 08:25:16 +0000</pubDate>
      
      <guid>https://wandong1.github.io/post/%E4%B8%BAk8s%E9%9B%86%E7%BE%A4%E6%B7%BB%E5%8A%A0nfs%E7%B1%BB%E5%9E%8B%E7%9A%84sotrageclass/</guid>
      <description>项目源码介绍 使用nfs-subdir-external-provisioner github地址：https://github.com/kubernetes-sigs/nfs-subdir-external-provisioner 详细介绍：https://artifacthub.io/packages/helm/nfs-subdir-external-provisioner/nfs-subdir-external-provisioner 镜像地址：https://hub.docker.com/r/eipwork/nfs-subdir-external-provisioner/tags
NFS服务端安装 # 安装nfs服务端 yum install nfs-utils -y vim /etc/exports /opt/nfsdata 192.168.0.0/24(rw,no_root_squash,no_all_squash,sync) # 刷新并验证 exportfs -rv # 启动nfs服务，共两个服务 systemctl enable rpcbind --now systemctl enable nfs --now 所有客户端也需要安装nfs-utils，安装完成即可，无需启动服务
yum install nfs-utils -y storageClass插件安装 # 添加helm仓库地址 helm repo add nfs-subdir-external-provisioner https://kubernetes-sigs.github.io/nfs-subdir-external-provisioner/ # 安装第一个 helm install nfs-subdir-external-provisioner nfs-subdir-external-provisioner/nfs-subdir-external-provisioner \ --set nfs.server=192.168.0.13 \ --set nfs.path=/opt/nfsdata \ --set image.repository=eipwork/nfs-subdir-external-provisioner # 安装第二个(可选) helm install second-nfs-subdir-external-provisioner nfs-subdir-external-provisioner/nfs-subdir-external-provisioner \ --set nfs.server=192.168.0.13 \ --set nfs.path=/opt/nfsdata2 \ --set image.</description>
    </item>
    
    <item>
      <title>Centos更新国内yum源</title>
      <link>https://wandong1.github.io/post/centos%E6%9B%B4%E6%96%B0%E5%9B%BD%E5%86%85yum%E6%BA%90/</link>
      <pubDate>Sun, 15 Aug 2021 08:15:16 +0000</pubDate>
      
      <guid>https://wandong1.github.io/post/centos%E6%9B%B4%E6%96%B0%E5%9B%BD%E5%86%85yum%E6%BA%90/</guid>
      <description>Centos7
wget -O /etc/yum.repos.d/epel-7.repo http://mirrors.aliyun.com/repo/epel-7.repo wget -O /etc/yum.repos.d/Centos-7.repo http://mirrors.aliyun.com/repo/Centos-7.repo wget -O /etc/yum.repos.d/CentOS7-Base-163.repo http://mirrors.163.com/.help/CentOS7-Base-163.repo </description>
    </item>
    
    <item>
      <title>ElasticSearch快速入门实战</title>
      <link>https://wandong1.github.io/post/elasticsearch/</link>
      <pubDate>Sun, 15 Aug 2021 08:15:16 +0000</pubDate>
      
      <guid>https://wandong1.github.io/post/elasticsearch/</guid>
      <description>ElasticSearch</description>
    </item>
    
    <item>
      <title>git的使用方法</title>
      <link>https://wandong1.github.io/post/git/</link>
      <pubDate>Sun, 15 Aug 2021 08:15:16 +0000</pubDate>
      
      <guid>https://wandong1.github.io/post/git/</guid>
      <description>Git Git 是一个开源的分布式版本控制软件,用以有效、高速的处理从很小到非常大的项目版本管理。 Git 最初是由Linus Torvalds设计开发的，用于管理Linux内核开发。Git 是根据GNU通用公共许可证版本2的条款分发的自由/免费软件，安装参见：http://git-scm.com/
打开git bash，初始化配置 git config --global user.name &amp;#34;wandong&amp;#34; git config --global user.email &amp;#34;993696910@qq.com&amp;#34; # 对已存在的目录进行git的初始化 git init # 添加远程仓库地址 git remote add origin http://git.cqzwymgmt.com/root/gin-project-orm.git # git add . git commit -m &amp;#34;Initial commit&amp;#34; # 推送到远程仓库 master分支 git push -u origin master 在新的环境拉取代码，进行开发 git clone http://git.cqzwymgmt.com/root/gin-project-orm.git # 创建新的分支继续开发 git branch dev # 列出所有分支 git branch # 切换分支 git checkout dev # 可以开始开发新功能了，尽量开发新的文件，避免合并的时候出现冲突进而解决冲突。 git add . git commit -m &amp;#34;change log function&amp;#34; # 推送到远程仓库 dev分支 git push -u origin dev 更新本地代码 # 拉取最新的dev分支代码，如果本地没有该分支，先创建 git branch dev # 使用pull命令更新分支代码的时候，要先处于该分支，不然会被合并 git branch dev git checkout dev git pull origin dev # 查看dev分支代码和master代码区别 将dev分支合并到master分支 git merge dev # 或者 git rebase dev 删除本地和远程仓库的分支 # 删除分支前先切换其他分支 git branch -d dev git push origin --delete dev 将你的仓库和你的gitee合并了，用填充的方法，即： git pull --rebase origin master </description>
    </item>
    
    <item>
      <title>离线安装docker</title>
      <link>https://wandong1.github.io/post/elasticsearch%E5%85%A5%E9%97%A8/</link>
      <pubDate>Sun, 15 Aug 2021 08:15:16 +0000</pubDate>
      
      <guid>https://wandong1.github.io/post/elasticsearch%E5%85%A5%E9%97%A8/</guid>
      <description>离线安装docker</description>
    </item>
    
    <item>
      <title>离线安装docker</title>
      <link>https://wandong1.github.io/post/%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/</link>
      <pubDate>Sun, 15 Aug 2021 08:15:16 +0000</pubDate>
      
      <guid>https://wandong1.github.io/post/%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/</guid>
      <description>离线安装docker</description>
    </item>
    
    <item>
      <title>随笔</title>
      <link>https://wandong1.github.io/post/%E9%9A%8F%E7%AC%94/</link>
      <pubDate>Sun, 15 Aug 2021 08:15:16 +0000</pubDate>
      
      <guid>https://wandong1.github.io/post/%E9%9A%8F%E7%AC%94/</guid>
      <description>随笔 技术的变革，一定是思想先行，云原生是一种构建和运行应用程序的方法，是一套技术体系和方法论。云原生（CloudNative）是一个组合词，Cloud+Native。Cloud表示应用程序位于云中，而不是传统的数据中心；Native表示应用程序从设计之初即考虑到云的环境，原生为云而设计，在云上以最佳姿势运行，充分利用和发挥云平台的弹性+分布式优势。
符合云原生架构的应用程序应该是：采用开源堆栈（K8S+Docker）进行容器化，基于微服务架构提高灵活性和可维护性，借助敏捷方法、DevOps支持持续迭代和运维自动化，利用云平台设施实现弹性伸缩、动态调度、优化资源利用率。
云原生的四要素 微服务：几乎每个云原生的定义都包含微服务，跟微服务相对的是单体应用，微服务有理论基础，那就是康威定律，指导服务怎么切分，很玄乎，凡是能称为理论定律的都简单明白不了，不然就忒没b格，大概意思是组织架构决定产品形态，不知道跟马克思的生产关系影响生产力有无关系。
微服务架构的好处就是按function切了之后，服务解耦，内聚更强，变更更易；另一个划分服务的技巧据说是依据DDD来搞。
容器化：Docker是应用最为广泛的容器引擎，在思科谷歌等公司的基础设施中大量使用，是基于LXC技术搞的，容器化为微服务提供实施保障，起到应用隔离作用，K8S是容器编排系统，用于容器管理，容器间的负载均衡，谷歌搞的，Docker和K8S都采用Go编写，都是好东西。
DevOps：这是个组合词，Dev+Ops，就是开发和运维合体，不像开发和产品，经常刀刃相见，实际上DevOps应该还包括测试，DevOps是一个敏捷思维，是一个沟通文化，也是组织形式，为云原生提供持续交付能力。
持续交付：持续交付是不误时开发，不停机更新，小步快跑，反传统瀑布式开发模型，这要求开发版本和稳定版本并存，其实需要很多流程和工具支撑。
如何云原生？ 首先，云原生借了云计算的东风，没有云计算，自然没有云原生，云计算是云原生的基础。
随着虚拟化技术的成熟和分布式框架的普及，在容器技术、可持续交付、编排系统等开源社区的推动下，以及微服务等开发理念的带动下，应用上云已经是不可逆转的趋势。
云计算的3层划分，即基础设施即服务(IaaS)、平台即服务(PaaS)、软件即服务(SaaS)为云原生提供了技术基础和方向指引，真正的云化不仅仅是基础设施和平台的变化，应用也需要做出改变，摈弃传统的土方法，在架构设计、开发方式、部署维护等各个阶段和方面都基于云的特点，重新设计，从而建设全新的云化的应用，即云原生应用。
1.本地部署的传统应用往往采用c/c++、企业级java编写，而云原生应用则需要用以网络为中心的go、node.js等新兴语言编写。
2.本地部署的传统应用可能需要停机更新，而云原生应用应该始终是最新的，需要支持频繁变更，持续交付，蓝绿部署。
3.本地部署的传统应用无法动态扩展，往往需要冗余资源以抵抗流量高峰，而云原生应用利用云的弹性自动伸缩，通过共享降本增效。
4.本地部署的传统应用对网络资源，比如ip、端口等有依赖，甚至是硬编码，而云原生应用对网络和存储都没有这种限制。
5.本地部署的传统应用通常人肉部署手工运维，而云原生应用这一切都是自动化的。
6.本地部署的传统应用通常依赖系统环境，而云原生应用不会硬连接到任何系统环境，而是依赖抽象的基础架构，从而获得良好移植性。
7.本地部署的传统应用有些是单体(巨石)应用，或者强依赖，而基于微服务架构的云原生应用，纵向划分服务，模块化更合理。
可见，要转向云原生应用需要以新的云原生方法开展工作，云原生包括很多方面：基础架构服务、虚拟化、容器化、容器编排、微服务。幸运的是，开源社区在云原生应用方面做出了大量卓有成效的工作，很多开源的框架和设施可以通过拿来主义直接用，2013年Docker推出并很快成为容器事实标准，随后围绕容器编排的混战中，2017年诞生的k8s很快脱颖而出，而这些技术极大的降低了开发云原生应用的技术门槛。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://wandong1.github.io/post/%E5%9F%BA%E4%BA%8Edocker%E5%92%8Ckubernetes%E7%9A%84%E4%BC%81%E4%B8%9A%E7%BA%A7devops%E5%AE%9E%E8%B7%B5%E8%AE%AD%E7%BB%83%E8%90%A5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://wandong1.github.io/post/%E5%9F%BA%E4%BA%8Edocker%E5%92%8Ckubernetes%E7%9A%84%E4%BC%81%E4%B8%9A%E7%BA%A7devops%E5%AE%9E%E8%B7%B5%E8%AE%AD%E7%BB%83%E8%90%A5/</guid>
      <description>基于Docker和Kubernetes的企业级DevOps实践训练营 课程准备 离线镜像包
百度：https://pan.baidu.com/s/1N1AYGCYftYGn6L0QPMWIMw 提取码：ev2h
天翼云：https://cloud.189.cn/t/ENjUbmRR7FNz
CentOS7.4版本以上 虚拟机3台（4C+8G+50G），内网互通，可连外网
课件文档
《训练营课件》 《安装手册》 git仓库
https://gitee.com/agagin/python-demo.git python demo项目
https://gitee.com/agagin/demo-resources.git demo项目演示需要的资源文件
关于本人 李永信
2012-2017，云平台开发工程师，先后对接过Vmware、OpenStack、Docker平台
2017-2019， 运维开发工程师，Docker+Kubernetes的Paas平台运维开发
2019至今，DevOps工程师
8年多的时间，积攒了一定的开发和运维经验，跟大家分享。
课程安排 2020.4.11 Docker + kubernetes
2020.4.18 DevOps平台实践
2天的时间，节奏会相对快一些
小调研：
A : 只听过docker，几乎没有docker的使用经验 B：有一定的docker实践经验，不熟悉或者几乎没用过k8s C：对于docker和k8s都有一定的实践经验，想更多了解如何基于docker+k8s构建devops平台 D：其他 课程介绍 最近的三年多时间，关注容器圈的话应该会知道这么几个事情：
容器技术持续火爆
Kubernetes(k8s)成为容器编排管理的标准
国内外厂商均已开始了全面拥抱Kubernetes的转型， 无数中小型企业已经落地 Kubernetes，或正走落地的道路上 。基于目前的发展趋势可以预见，未来几年以kubernetes平台为核心的容器运维管理、DevOps等将迎来全面的发展。
本着实践为核心的思想，本课程使用企业常见的基于Django + uwsgi + Nginx架构的Python Demo项目，分别讲述三个事情：
项目的容器化
教大家如何把公司的项目做成容器，并且运行在docker环境中
使用Kubernetes集群来管理容器化的项目
带大家一步一步部署k8s集群，并把容器化后的demo项目使用k8s来管理起来
使用Jenkins和Kubernetes集成，实现demo项目的持续集成/持续交付(CI/CD)
会使用k8s管理应用生命周期后，还差最后的环节，就是如何把开发、测试、部署的流程使用自动化工具整合起来，最后一部分呢，课程会教会大家如何优雅的使用gitlab+Jenkins+k8s构建企业级的DevOps平台
流程示意 你将学到哪些 Docker相关
如何使用Dockerfile快速构建镜像 Docker镜像、容器、仓库的常用操作 Docker容器的网络（Bridge下的SNAT、DNAT） Kubernetes相关
集群的快速搭建 kubernetes的架构及工作流程 使用Pod控制器管理业务应用的生命周期 使用CoreDNS、Service和Ingress实现服务发现、负载均衡及四层、七层网络的访问 Kubernetes的认证授权体系 使用EFK构建集群业务应用的日志收集系统</description>
    </item>
    
    <item>
      <title>docker入门至进阶</title>
      <link>https://wandong1.github.io/post/docker%E5%85%A5%E9%97%A8%E8%87%B3%E8%BF%9B%E9%98%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://wandong1.github.io/post/docker%E5%85%A5%E9%97%A8%E8%87%B3%E8%BF%9B%E9%98%B6/</guid>
      <description>一、Docker是什么 使用最广泛的开源容器引擎 一种操作系统级的虚拟化技术 依赖于Linux内核特性：Namespace（资源隔离）和Cgroups（资源限制） 一个简单的应用程序打包工具 docker的安装docker的安装 安装依赖包 mkdir /etc/yum.repos.d/back mv /etc/yum.repos.d/* /etc/yum.repos.d/back wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo yum install -y yum-utils 添加Docker软件包源 yum-config-manager \ --add-repo \ https://download.docker.com/linux/centos/docker-ce.repo 安装Docker CE yum install -y docker-ce 启动Docker服务并设置开机启动 systemctl start docker systemctl enable docker https://docs.docker.com/engine/install/centos/ 官方文档：https://docs.docker.com 阿里云源：http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
二、镜像是什么？ 一个分层存储的文件，不是一个单一的文件 一个软件的环境 一个镜像可以创建N个容器 一种标准化的交付 一个不包含Linux内核而又精简的Linux操作系统 镜像从哪里来 Docker Hub是由Docker公司负责维护的公共镜像仓库，包含大量的容器镜像，Docker工具默认从这个公共镜像库下载镜像。 地址：https://hub.docker.com 配置镜像加速器：
vi /etc/docker/daemon.json { &amp;#34;registry-mirrors&amp;#34;: [&amp;#34;https://b9pmyelo.mirror.aliyuncs.com&amp;#34;] } 镜像相关命令 镜像加速器获取地址： 阿里云&amp;gt;控制台&amp;gt;容器镜像服务&amp;gt;镜像工具&amp;gt;镜像加速器 https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors docker image docker export 9a495b209d08 -o tomcat.tar</description>
    </item>
    
    <item>
      <title>docker部署jenkins</title>
      <link>https://wandong1.github.io/post/docker%E9%83%A8%E7%BD%B2jenkins/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://wandong1.github.io/post/docker%E9%83%A8%E7%BD%B2jenkins/</guid>
      <description>创建服务 docker volume create jenkins-data docker run -d --name jenkins -p 80:8080 -p 50000:50000 -v jenkins-data:/var/jenkins_home jenkins/jenkins 查看首次登录密钥 docker logs jenkins # 或者 cat /var/jenkins_home/secrets/initialAdminPassword 修改国内插件源 # 进入jenkins_home/updates目录 sed -i &amp;#39;s/http:\/\/updates.jenkins.ci.org\/download/https:\/\/mirrors.tuna.tsinghua.edu.cn\/jenkins/g&amp;#39; default.json sed -i &amp;#39;s/http:\/\/www.google.com/https:\/\/www.baidu.com/g&amp;#39; default.json 管理Jenkins-&amp;gt;系统配置&amp;ndash;&amp;gt;管理插件&amp;ndash;&amp;gt;分别搜索Git Parameter/Git/Pipeline/kubernetes/Config File Provider， 选中点击安装。
• Git：拉取代码
• Git Parameter：Git参数化构建
• Pipeline：流水线
• kubernetes：连接Kubernetes动态创建Slave代理
• Config File Provider：存储配置文件
• Extended Choice Parameter：扩展选择框参数，支持多选
pipeline { agent any stages { stage(&amp;#39;pull code&amp;#39;) { steps { git credentialsId: &amp;#39;fd53dd28-a24f-48ce-b6a3-edaefef0c61a&amp;#39;, url: &amp;#39;https://github.</description>
    </item>
    
    <item>
      <title>docker镜像制作</title>
      <link>https://wandong1.github.io/post/docker%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://wandong1.github.io/post/docker%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/</guid>
      <description>六、Dockerfile定制容器镜像 Dockerfile常用指令 docker build构建镜像 Usage: docker build [OPTIONS] PATH | URL | -[flags]Options: -t, &amp;ndash;tag list # 镜像名称 -f, &amp;ndash;file string # 指定Dockerfile文件位置
docker build -t shykes/myapp . docker build -t shykes/myapp -f /path/Dockerfile /path docker build -t shykes/myapp http://www.example.com/Dockerfile CMD与ENTRYPOINT区别 CMD用法： •CMD [“executable”,“param1”,“param2”] ：exec形式（首选） •CMD [“param1”,“param2”] ：作为ENTRYPOINT的默认参数 •CMD command param1 param2 ：Shell形式 ENTRYPOINT用法： •ENTRYPOINT [&amp;ldquo;executable&amp;rdquo;, &amp;ldquo;param1&amp;rdquo;, &amp;ldquo;param2&amp;rdquo;] •ENTRYPOINT command param1 param2
小结： 1.CMD和ENTRYPOINT指令都可以用来定义运行容器时所使用的默认命令 2.Dockerfile至少指定一个CMD或ENTRYPOINT 3.CMD可以用作ENTRYPOINT默认参数，或者用作容器的默认命令 4.docker run指定时，将会覆盖CMD 5.如果是可执行文件，希望运行时传参，应该使用ENTRYPOINT
构建镜像例子 构建tomcat镜像，需要apache-tomcat-8.</description>
    </item>
    
    <item>
      <title>expect实现免交互登录</title>
      <link>https://wandong1.github.io/post/expect%E5%AE%9E%E7%8E%B0%E5%85%8D%E4%BA%A4%E4%BA%92%E7%99%BB%E5%BD%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://wandong1.github.io/post/expect%E5%AE%9E%E7%8E%B0%E5%85%8D%E4%BA%A4%E4%BA%92%E7%99%BB%E5%BD%95/</guid>
      <description>expect 安装 yum install -y expect 免交互切root用户 #!/usr/bin/expect set passwd &amp;#34;123456&amp;#34; set timeout 10 spawn su - expect { &amp;#34;Password:&amp;#34; { send &amp;#34;$passwd\r&amp;#34; } } interact 免交互ssh登录节点 #!/usr/bin/expect set timeout 10 set passwd &amp;#34;123456&amp;#34; spawn ssh wanye@172.17.0.17 -p 22 expect { &amp;#34;yes/no&amp;#34; { send &amp;#34;yes\r&amp;#34;;exp_continue } &amp;#34;password:&amp;#34; { send &amp;#34;$passwd\r&amp;#34; } } interact </description>
    </item>
    
    <item>
      <title>Hello World</title>
      <link>https://wandong1.github.io/post/hello-world/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://wandong1.github.io/post/hello-world/</guid>
      <description>Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.
Quick Start Create a new post $ hexo new &amp;#34;My New Post&amp;#34; More info: Writing
Run server $ hexo server More info: Server
Generate static files $ hexo generate More info: Generating
Deploy to remote sites $ hexo deploy More info: Deployment</description>
    </item>
    
    <item>
      <title>k8s集群负载均衡keepalived&#43;nginx实现</title>
      <link>https://wandong1.github.io/post/k8s%E9%9B%86%E7%BE%A4%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1keepalived&#43;nginx%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://wandong1.github.io/post/k8s%E9%9B%86%E7%BE%A4%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1keepalived&#43;nginx%E5%AE%9E%E7%8E%B0/</guid>
      <description>使用keepalived实现vip的动态飘逸 keepalived.conf 主
! Configuration File for keepalived global_defs { notification_email { acassen@firewall.loc failover@firewall.loc sysadmin@firewall.loc } notification_email_from Alexandre.Cassen@firewall.loc smtp_server 192.168.200.1 smtp_connect_timeout 30 router_id LVS_DEVEL vrrp_skip_check_adv_addr vrrp_garp_interval 0 vrrp_gna_interval 0 } vrrp_script check_nginx { script &amp;#34;/etc/keepalived/check_nginx.sh&amp;#34; } vrrp_instance VI_1{ state MASTER interface ens34 virtual_router_id 51 priority 100 advert_int 1 authentication { auth_tpye PASS auth_pass 1111 } virtual_ipaddress { 192.168.200.59/24 } track_script { check_nginx } } keepalived.conf 备
! Configuration File for keepalived global_defs { notification_email { acassen@firewall.</description>
    </item>
    
    <item>
      <title>kubeadm安装K8S集群</title>
      <link>https://wandong1.github.io/post/kubeadm%E5%AE%89%E8%A3%85k8s%E9%9B%86%E7%BE%A4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://wandong1.github.io/post/kubeadm%E5%AE%89%E8%A3%85k8s%E9%9B%86%E7%BE%A4/</guid>
      <description>kubeadm是官方社区推出的一个用于快速部署kubernetes集群的工具。
这个工具能通过两条指令完成一个kubernetes集群的部署：
# 创建一个 Master 节点$ kubeadm init# 将一个 Node 节点加入到当前集群中$ kubeadm join &amp;lt;Master节点的IP和端口 &amp;gt; 1. 安装要求 在开始之前，部署Kubernetes集群机器需要满足以下几个条件：
一台或多台机器，操作系统 CentOS7.x-86_x64 硬件配置：2GB或更多RAM，2个CPU或更多CPU，硬盘30GB或更多 集群中所有机器之间网络互通 可以访问外网，需要拉取镜像 禁止swap分区 2. 准备环境 角色 IP k8s-master 192.168.31.61 k8s-node1 192.168.31.62 k8s-node2 192.168.31.63 关闭防火墙：$ systemctl stop firewalld$ systemctl disable firewalld关闭selinux：$ sed -i &amp;#39;s/enforcing/disabled/&amp;#39; /etc/selinux/config # 永久$ setenforce 0 # 临时关闭swap：$ swapoff -a # 临时$ vim /etc/fstab # 永久设置主机名：$ hostnamectl set-hostname &amp;lt;hostname&amp;gt;在master添加hosts：$ cat &amp;gt;&amp;gt; /etc/hosts &amp;lt;&amp;lt; EOF192.</description>
    </item>
    
    <item>
      <title>kubectl命令补全</title>
      <link>https://wandong1.github.io/post/kubectl%E5%91%BD%E4%BB%A4%E8%A1%A5%E5%85%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://wandong1.github.io/post/kubectl%E5%91%BD%E4%BB%A4%E8%A1%A5%E5%85%A8/</guid>
      <description>一、kubectl命令补全 yum install -y bash-completion #临时生效
source /usr/share/bash-completion/bash_completion #永久生效
source &amp;lt;(kubectl completion bash) echo &amp;#34;source &amp;lt;(kubectl completion bash)&amp;#34; &amp;gt;&amp;gt; ~/.bashrc </description>
    </item>
    
    <item>
      <title>kubectl管理命令概要</title>
      <link>https://wandong1.github.io/post/kubectl%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4%E6%A6%82%E8%A6%81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://wandong1.github.io/post/kubectl%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4%E6%A6%82%E8%A6%81/</guid>
      <description>kubectl管理命令概要 配置命令补全： http://123.207.224.155:8080/post/60
体验 使用Deployment控制器部署镜像：
kubectl create deployment web --image=lizhenliang/java-demo kubectl get deploy,pods 使用Service将Pod暴露出去：
kubectl expose deployment web --port=80 --target-port=8080 --type=NodePort kubectl get service 访问应用： http://NodeIP:Port # 端口随机生成，通过get svc获取
查看资源并显示标签
kubectl get pods --show-labels 根据查看带有指定标签名字的资源
kubectl get pod -l app=web https://kubernetes.io/docs 官方资料查询
YAML字段记忆技巧 用create命令生成 kubectl create deployment nginx --image=nginx:1.16 -o yaml --dry-run=client &amp;gt; my-deploy.yaml 用get命令导出 kubectl get deploymentnginx-o yaml &amp;gt; my-deploy.yaml Pod容器的字段拼写忘记了 kubectl explain pods.spec.containers kubectl explain deployment </description>
    </item>
    
    <item>
      <title>linux系统根分区扩容</title>
      <link>https://wandong1.github.io/post/linux%E7%B3%BB%E7%BB%9F%E6%A0%B9%E5%88%86%E5%8C%BA%E6%89%A9%E5%AE%B9/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://wandong1.github.io/post/linux%E7%B3%BB%E7%BB%9F%E6%A0%B9%E5%88%86%E5%8C%BA%E6%89%A9%E5%AE%B9/</guid>
      <description>扩容硬盘后进行如下操作。
fdisk /dev/vda1 确认只有一个vda1分区的情况下，按d删除分区，然后按n重新创建vda1分区，指定更大范围的sectors,且覆盖原有的sectors。 重启机器，后 resize2fs /dev/vda1
https://help.aliyun.com/document_detail/113316.html</description>
    </item>
    
    <item>
      <title>linux系统负载高排查</title>
      <link>https://wandong1.github.io/post/linux%E7%B3%BB%E7%BB%9F%E8%B4%9F%E8%BD%BD%E9%AB%98%E6%8E%92%E6%9F%A5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://wandong1.github.io/post/linux%E7%B3%BB%E7%BB%9F%E8%B4%9F%E8%BD%BD%E9%AB%98%E6%8E%92%E6%9F%A5/</guid>
      <description>uptime 查看负载高 uptime uptime 命令用于查看服务器运行了多长时间以及有多少个用户登录，快速获知服务器的负荷情况。
uptime 的输出包含一项内容是 load average，显示了最近 1，5，15 分钟的负荷情况。它的值代表等待CPU 处理的进程数，如果 CPU 没有时间处理这些进程，load average 值会升高；反之则会降低。load average的最佳值是 1，说明每个进程都可以马上处理并且没有CPU cycles 被丢失。对于单 CPU 的机器，1 或者2 是可以接受的值；对于多路 CPU 的机器，load average 值可能在 8 到 10 之间。也可以使用 uptime 命令来判断网络性能。例如，某个网络应用性能很低，通过运行uptime 查看服务器的负荷是否很高，如果不是，那么问题应该是网络方面造成的。
以下是 uptime 的运行实例： 9:24am up 19:06, 1 user, load average: 0.00, 0.00, 0.00 也可以查看/proc/loadavg 和/proc/uptime 两个文件，注意不能编辑/proc 中的文件，要用 cat 等命令来查看，如：
cat /proc/loadavg 0.0 0.00 0.00 1/55 5505 uptime 命令用法十分简单：直接输入
uptime 例： 18:02:41 up 41 days, 23:42,	1 user,	load average: 0.</description>
    </item>
    
    <item>
      <title>lvm逻辑卷管理</title>
      <link>https://wandong1.github.io/post/lvm%E9%80%BB%E8%BE%91%E5%8D%B7%E7%AE%A1%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://wandong1.github.io/post/lvm%E9%80%BB%E8%BE%91%E5%8D%B7%E7%AE%A1%E7%90%86/</guid>
      <description>LVM的工作原理 LVM（ Logical Volume Manager）逻辑卷管理，是在磁盘分区和文件系统之间添加的一个逻辑层，来为文件系统屏蔽下层磁盘分区布局，提供一个抽象的盘卷，在盘卷上建立文件系统。管理员利用LVM可以在磁盘不用重新分区的情况下动态调整文件系统的大小，并且利用LVM管理的文件系统可以跨越磁盘，当服务器添加了新的磁盘后，管理员不必将原有的文件移动到新的磁盘上，而是通过LVM可以直接扩展文件系统跨越磁盘
它就是通过将底层的物理硬盘封装起来，然后以逻辑卷的方式呈现给上层应用。在LVM中，其通过对底层的硬盘进行封装，当我们对底层的物理硬盘进行操作时，其不再是针对于分区进行操作，而是通过一个叫做逻辑卷的东西来对其进行底层的磁盘管理操作。
LVM常用的术语 物理存储介质（The physical media）:LVM存储介质可以是磁盘分区，整个磁盘，RAID阵列或SAN磁盘，设备必须初始化为LVM物理卷，才能与LVM结合使用
物理卷PV（physical volume） ：物理卷就是LVM的基本存储逻辑块，但和基本的物理存储介质（如分区、磁盘等）比较，却包含有与LVM相关的管理参数,创建物理卷它可以用硬盘分区，也可以用硬盘本身；
卷组VG（Volume Group） ：一个LVM卷组由一个或多个物理卷组成 
逻辑卷LV（logical volume） ：LV建立在VG之上，可以在LV之上建立文件系统
PE（physical extents） ：PV物理卷中可以分配的最小存储单元，PE的大小是可以指定的，默认为4MB
LE（logical extent） ： LV逻辑卷****中可以分配的最小存储单元，在同一个卷组中，LE的大小和PE是相同的，并且一一对应
最小存储单位总结：
名称 最小存储单位
硬盘 扇区（512字节）
文件系统 block（1K或4K ）# mkfs.ext4 -b 2048 /dev/sdb1 ，最大支持到4096
raid chunk （512K） #mdadm -C -v /dev/md5 -l 5 -n 3 -c 512 -x 1 /dev/sde{1,2,3,5}
LVM PE （4M） # vgcreate -s 4M vg1 /dev/sdb{1,2}
LVM主要元素构成： 总结：多个磁盘/分区/raid-》多个物理卷PV-》合成卷组VG-》从VG划出逻辑卷LV-》格式化LV挂载使用
LVM优点 使用卷组，使多个硬盘空间看起来像是一个大的硬盘
使用逻辑卷，可以跨多个硬盘空间的分区 sdb1 sdb2 sdc1 sdd2 sdf</description>
    </item>
    
    <item>
      <title>nginx限流熔断</title>
      <link>https://wandong1.github.io/post/nginx%E9%99%90%E6%B5%81%E7%86%94%E6%96%AD/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://wandong1.github.io/post/nginx%E9%99%90%E6%B5%81%E7%86%94%E6%96%AD/</guid>
      <description>Nginx限流熔断 作为优秀的负载均衡模块，目前是我们工作中用到最多的。其实，该模块是提供了我们需要的后端限流功能的。通过官方文档介绍，
令牌桶算法 算法思想是：
令牌以固定速率产生，并缓存到令牌桶中； 令牌桶放满时，多余的令牌被丢弃； 请求要消耗等比例的令牌才能被处理； 令牌不够时，请求被缓存。 漏桶算法 算法思想是：
水（请求）从上方倒入水桶，从水桶下方流出（被处理）； 来不及流出的水存在水桶中（缓冲），以固定速率流出； 水桶满后水溢出（丢弃）。 这个算法的核心是：缓存请求、匀速处理、多余的请求直接丢弃。 相比漏桶算法，令牌桶算法不同之处在于它不但有一只“桶”，还有个队列，这个桶是用来存放令牌的，队列才是用来存放请求的。 从作用上来说，漏桶和令牌桶算法最明显的区别就是是否允许突发流量(burst)的处理，漏桶算法能够强行限制数据的实时传输（处理）速率，对突发流量不做额外处理；而令牌桶算法能够在限制数据的平均传输速率的同时允许某种程度的突发传输。
Nginx按请求速率限速模块使用的是漏桶算法，即能够强行保证请求的实时处理速度不会超过设置的阈值。
案例 通过查看nginx官方文档，https://www.nginx.cn/doc/
HttpLimit zone 本模块可以针对条件，进行会话的并发连接数控制。（例如：限制每个IP的并发连接数。）
配置示例
http {: limit_zone one $binary_remote_addr 10m;: ...: server {: ...: location /download/ {: limit_conn one 1;: } 指令 [#limit_zone limit_zone] [#limit_conn limit_conn] limit_zone 语法： limit_zone zone_name $variable the_size
默认值： no
作用域： http
本指令定义了一个数据区，里面记录会话状态信息。 $variable 定义判断会话的变量；the_size 定义记录区的总容量。
例子：
limit_zone one $binary_remote_addr 10m; 定义一个叫“one”的记录区，总容量为 10M，以变量 $binary_remote_addr 作为会话的判断基准（即一个地址一个会话）。</description>
    </item>
    
    <item>
      <title>python consul注册中心客户端代码范例</title>
      <link>https://wandong1.github.io/post/python-consul%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A3%E7%A0%81%E8%8C%83%E4%BE%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://wandong1.github.io/post/python-consul%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A3%E7%A0%81%E8%8C%83%E4%BE%8B/</guid>
      <description>import consul from random import randint import requests import json class ConsulClient(): &amp;#39;&amp;#39;&amp;#39;定义consul操作类&amp;#39;&amp;#39;&amp;#39; def __init__(self, host=None, port=None, token=None): &amp;#39;&amp;#39;&amp;#39;初始化，指定consul主机、端口和token&amp;#39;&amp;#39;&amp;#39; self.host = host # consul 主机 self.port = port # consul 端口 self.token = token self.consul = consul.Consul(host=host, port=port) def register(self, name, service_id, address, port, tags, interval, url): &amp;#39;&amp;#39;&amp;#39;注册服务&amp;#39;&amp;#39;&amp;#39; # 设置检测模式：http和tcp # tcp模式 # check=consul.Check().tcp(self.host, self.port, # &amp;#34;5s&amp;#34;, &amp;#34;30s&amp;#34;, &amp;#34;30s&amp;#34;) # http模式 check = consul.Check().http(url, interval, timeout=None, deregister=None, header=None) self.consul.agent.service.register(name, service_id=service_id, address=address, port=port, tags=tags, interval=interval, check=check) def getService(self, name): &amp;#39;&amp;#39;&amp;#39;通过负载均衡获取服务实例&amp;#39;&amp;#39;&amp;#39; # 获取相应服务下的DataCenter url = &amp;#39;http://&amp;#39; + self.</description>
    </item>
    
    <item>
      <title>redis工具之redis_rdb_tools</title>
      <link>https://wandong1.github.io/post/redis%E5%B7%A5%E5%85%B7%E4%B9%8Bredis_rdb_tools/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://wandong1.github.io/post/redis%E5%B7%A5%E5%85%B7%E4%B9%8Bredis_rdb_tools/</guid>
      <description>安装工具 指定pip源安装
pip install rdbtools -i https://mirrors.aliyun.com/pypi/simple/ pip install python-lzf -i https://mirrors.aliyun.com/pypi/simple/ 生成内存报告 rdb -c memory dump.rdb &amp;gt; redis_memory_report.csv
详细参考：https://www.cnblogs.com/xingxia/p/redis_rdb_tools.html</description>
    </item>
    
    <item>
      <title>redis抓包分析</title>
      <link>https://wandong1.github.io/post/redis%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://wandong1.github.io/post/redis%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/</guid>
      <description>tcpdump -i bond0 tcp and port 3029 and host 10.42.23.141 -n -nn -vvv -w redis2.cap data and tcp.dstport == 3034
import dpkt import socket from openpyxl import Workbook def analysis_of_redis_cap(cap_file,redis_port): wb = Workbook() ws = wb.active table_hed = [&amp;#39;源地址&amp;#39;,&amp;#39;目的地址&amp;#39;,&amp;#39;redis请求命令&amp;#39;] ws.append(table_hed) with open(cap_file,&amp;#39;rb&amp;#39;) as f: string_data = dpkt.pcap.Reader(f) for ts, buf in string_data: eth = dpkt.ethernet.Ethernet(buf) ip = eth.data tcp = ip.data # print(tcp.dport) if tcp.dport == int(redis_port): try: data_pre = tcp.</description>
    </item>
    
    <item>
      <title>tcp三次握手和四次挥手</title>
      <link>https://wandong1.github.io/post/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://wandong1.github.io/post/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</guid>
      <description>TCP 协议简述 TCP 提供面向有连接的通信传输，面向有连接是指在传送数据之前必须先建立连接，数据传送完成后要释放连接。
无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。 同时由于TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议，TCP是全双工模式，所以需要四次挥手关闭连接。
TCP包首部 网络中传输的数据包由两部分组成：一部分是协议所要用到的首部，另一部分是上一层传过来的数据。首部的结构由协议的具体规范详细定义。在数据包的首部，明确标明了协议应该如何读取数据。反过来说，看到首部，也就能够了解该协议必要的信息以及所要处理的数据。包首部就像协议的脸。
所以我们在学习TCP协议之前，首先要知道TCP在网络传输中处于哪个位置，以及它的协议的规范，下面我们就看看TCP首部的网络传输起到的作用：
下面的图是TCP头部的规范定义，它定义了TCP协议如何读取和解析数据： TCP首部承载这TCP协议需要的各项信息，下面我们来分析一下：
TCP端口号 TCP的连接是需要四个要素确定唯一一个连接： （源IP，源端口号）+ （目地IP，目的端口号） 所以TCP首部预留了两个16位作为端口号的存储，而IP地址由上一层IP协议负责传递 源端口号和目地端口各占16位两个字节，也就是端口的范围是2^16=65535 另外1024以下是系统保留的，从1024-65535是用户使用的端口范围
TCP的序号和确认号： 32位序号 seq：Sequence number 缩写seq ，TCP通信过程中某一个传输方向上的字节流的每个字节的序号，通过这个来确认发送的数据有序，比如现在序列号为1000，发送了1000，下一个序列号就是2000。 32位确认号 ack：Acknowledge number 缩写ack，TCP对上一次seq序号做出的确认号，用来响应TCP报文段，给收到的TCP报文段的序号seq加1。
TCP的标志位 每个TCP段都有一个目的，这是借助于TCP标志位选项来确定的，允许发送方或接收方指定哪些标志应该被使用，以便段被另一端正确处理。 用的最广泛的标志是 SYN，ACK 和 FIN，用于建立连接，确认成功的段传输，最后终止连接。
**SYN：**简写为S，同步标志位，用于建立会话连接，同步序列号； ACK： 简写为.，确认标志位，对已接收的数据包进行确认； FIN： 简写为F，完成标志位，表示我已经没有数据要发送了，即将关闭连接； **PSH：**简写为P，推送标志位，表示该数据包被对方接收后应立即交给上层应用，而不在缓冲区排队； **RST：**简写为R，重置标志位，用于连接复位、拒绝错误和非法的数据包； **URG：**简写为U，紧急标志位，表示数据包的紧急指针域有效，用来保证连接不被阻断，并督促中间设备尽快处理；
TCP 三次握手建立连接 所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个报文。
三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 connect() 时。将触发三次握手。
三次握手过程的示意图如下： 第一次握手： 客户端将TCP报文标志位SYN置为1，随机产生一个序号值seq=J，保存在TCP首部的序列号(Sequence Number)字段里，指明客户端打算连接的服务器的端口，并将该数据包发送给服务器端，发送完毕后，客户端进入SYN_SENT状态，等待服务器端确认。
第二次握手： 服务器端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务器端将TCP报文标志位SYN和ACK都置为1，ack=J+1，随机产生一个序号值seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD状态。
第三次握手： 客户端收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务器端，服务器端检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入ESTABLISHED状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。
**注意:**我们上面写的ack和ACK，不是同一个概念：
小写的ack代表的是头部的确认号Acknowledge number， 缩写ack，是对上一个包的序号进行确认的号，ack=seq+1。 大写的ACK，则是我们上面说的TCP首部的标志位，用于标志的TCP包是否对上一个包进行了确认操作，如果确认了，则把ACK标志位设置成1。 下面我自己做实验，开一个HTTP服务，监听80端口，然后使用Tcpdump命令抓包，看一下TCP三次握手的过程：</description>
    </item>
    
    <item>
      <title>tsar安装和使用</title>
      <link>https://wandong1.github.io/post/tsar%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://wandong1.github.io/post/tsar%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</guid>
      <description>从github上检出代码从github上检出代码 $ git clone git://github.com/alibaba/tsar.git $ cd tsar $ make $ make install 从github上下载源码 $ wget -O tsar.zip https://github.com/alibaba/tsar/archive/master.zip --no-check-certificate $ unzip tsar.zip $ cd tsar $ make $ make install 安装后生成的文件 Tsar配置文件路径：/etc/tsar/tsar.conf，tsar的采集模块和输出的具体配置； 定时任务配置:/etc/cron.d/tsar，负责每分钟调用tsar执行采集任务； 日志文件轮转配置:/etc/logrotate.d/tsar，每个月会把tsar的本地存储进行轮转； 模块路径：/usr/local/tsar/modules，各个模块的动态库so文件；
详细参考：https://www.cnblogs.com/zafu/p/11782988.html</description>
    </item>
    
    <item>
      <title>企业级镜像仓库harbor</title>
      <link>https://wandong1.github.io/post/%E4%BC%81%E4%B8%9A%E7%BA%A7%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93harbor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://wandong1.github.io/post/%E4%BC%81%E4%B8%9A%E7%BA%A7%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93harbor/</guid>
      <description>概述 Harbor是由VMWare公司开源的容器镜像仓库。事实上，Harbor是在Docker Registry上进行了相应的企业级扩展，从而获得了更加广泛的应用，这些新的企业级特性包括：管理用户界面，基于角色的访问控制，AD/LDAP集成以及审计日志等，足以满足基本企业需求。 官方：https://goharbor.io/ Github：https://github.com/goharbor/harbor
部署先决条件 服务器硬件配置： •最低要求：CPU2核/内存4G/硬盘40GB •推荐：CPU4核/内存8G/硬盘160GB 软件： •Docker CE 17.06版本+ •Docker Compose1.18版本+ Harbor安装有2种方式： •在线安装：从Docker Hub下载Harbor相关镜像，因此安装软件包非常小 •离线安装：安装包包含部署的相关镜像，因此安装包比较大
Harbor部署HTTP 1、先安装Docker和Docker Compose https://github.com/docker/compose/releases
mv docker-compose-Linux-x86_64 /usr/bin/docker-compose &amp;amp;&amp;amp; chmod +x /usr/bin/docker-compose 2、部署Harbor HTTP https://github.com/goharbor/harbor/releases
tar zxvf harbor-offline-installer-v2.0.0.tgz cd harbor cp harbor.yml.tmpl harbor.yml vi harbor.yml hostname: reg.myharbor.com https: # 先注释https相关配置 harbor_admin_password: Harbor12345 ./prepare ./install.sh # 查看已安装的依赖容器 docker-compose ps # 重启docker-compose docker-compose down docker-compose up -d web界面登录：IP：80端口访问， 用户名 admin/Harbor12345
http部署方式基本使用 1、配置http镜像仓库可信任
vi /etc/docker/daemon.json {&amp;#34;insecure-registries&amp;#34;:[&amp;#34;reg.</description>
    </item>
    
    <item>
      <title>网络设备巡检命令</title>
      <link>https://wandong1.github.io/post/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E5%B7%A1%E6%A3%80%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://wandong1.github.io/post/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E5%B7%A1%E6%A3%80%E5%91%BD%E4%BB%A4/</guid>
      <description>display clock display license display version dir display boot-loader display cpu-usage display memory display environment display device verbose display device manuinfo display power display fan display alarm display transceiver alarm interface display transceiver diagnosis interface display stp brief display stp root display stp reg display arp display mac-address display vrrp display interface display interface brief display counters inbound interface display counters outbound interface display counters rate inbound interface display counters rate inbound interface display lldp neighbor-information list display irf display irf link display irf topology display logbuffer display current-configuration </description>
    </item>
    
    <item>
      <title>钉钉群机器人推送脚本</title>
      <link>https://wandong1.github.io/post/%E9%92%89%E9%92%89%E7%BE%A4%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%8E%A8%E9%80%81%E8%84%9A%E6%9C%AC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://wandong1.github.io/post/%E9%92%89%E9%92%89%E7%BE%A4%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%8E%A8%E9%80%81%E8%84%9A%E6%9C%AC/</guid>
      <description>import requests import json import os, sys class PushMessage: def __init__(self): # self.test_ip_lst = [&amp;#39;114.114.114.114&amp;#39;,&amp;#39;223.5.5.5&amp;#39;] self.test_ip_lst = [&amp;#34;23.134.37.253&amp;#34;,&amp;#34;59.214.26.21&amp;#34;,&amp;#34;23.137.37.1&amp;#34;] self.alarm_info = &amp;#39;电子政务外网地址探测:\n&amp;#39; self.is_atall = &amp;#39;false&amp;#39; self.dingding_url = &amp;#34;https://oapi.dingtalk.com/robot/send?access_token=1c1&amp;#34; self.push = False def dingding_qun(self): headers = { &amp;#39;Content-Type&amp;#39;: &amp;#39;application/json;charset=utf-8&amp;#39; } url = &amp;#34;&amp;#34;&amp;#34;{}&amp;#34;&amp;#34;&amp;#34;.format(self.dingding_url) # data_markdown = { # &amp;#34;msgtype&amp;#34;: &amp;#34;markdown&amp;#34;, # &amp;#34;markdown&amp;#34;: { # &amp;#34;title&amp;#34;:&amp;#34;杭州天气&amp;#34;, # &amp;#34;text&amp;#34;: &amp;#34;#### 杭州天气 @18182294500 \n&amp;gt; 9度，西北风1级，空气良89，相对温度73%\n&amp;gt; ![screenshot](https://img.alicdn.com/tfs/TB1NwmBEL9TBuNjy1zbXXXpepXa-2400-1218.png)\n&amp;gt; ###### 10点20分发布 [天气](https://www.dingalk.com) \n&amp;#34; # }, # &amp;#34;at&amp;#34;: { # &amp;#34;atMobiles&amp;#34;: [ # &amp;#34;18500&amp;#34; # ], # &amp;#34;atUserIds&amp;#34;: [ # &amp;#34;user123&amp;#34; # ], # &amp;#34;isAtAll&amp;#34;: &amp;#34;false&amp;#34; # } # } data_text = { &amp;#34;at&amp;#34;: { &amp;#34;atMobiles&amp;#34;: [ &amp;#34;&amp;#34; ], &amp;#34;atUserIds&amp;#34;: [ &amp;#34;user123&amp;#34; ], &amp;#34;isAtAll&amp;#34;: &amp;#34;{}&amp;#34;.</description>
    </item>
    
  </channel>
</rss>
