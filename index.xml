<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>万东的技术博客</title>
    <link>http://example.org/</link>
    <description>Recent content on 万东的技术博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 14 Sep 2022 16:14:24 +0000</lastBuildDate><atom:link href="http://example.org/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>helm的使用方法介绍</title>
      <link>http://example.org/post/helm%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>Wed, 14 Sep 2022 16:14:24 +0000</pubDate>
      
      <guid>http://example.org/post/helm%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</guid>
      <description>HelmHelm是一个Kubernetes的包管理工具，就像Linux下的包管理器，如yum/apt等，可以很方便的将之前
打包好的yaml文件部署到kubernetes上。
Helm有3个重要概念：
• **helm：**一个命令行客户端工具，主要用于Kubernetes应用chart的创建、打包、发布和管理。
• **Chart：**应用描述，一系列用于描述 k8s 资源相关文件的集合。
• **Release：**基于Chart的部署实体，一个 chart 被 Helm 运行后将会生成对应的一个 release；将在
k8s中创建出真实运行的资源对象。
Helm客户端使用helm很简单，你只需要下载一个二进制客户端包即可，会通过kubeconfig配置（通常$HOME/.kube/config）来连接Kubernetes。
项目地址：https://github.com/helm/helm
下载Helm客户端：
wget https://get.helm.sh/helm-v3.4.2-linux-amd64.tar.gz tar zxvf helm-v3.4.2-linux-amd64.tar.gz mv linux-amd64/helm /usr/bin/ Helm常用命令Helm管理应用生命周期：• helm create 创建Chart示例
• helm install 部署
• helm upgrade 更新
• helm rollback 回滚
• helm uninstall 卸载
Helm基本使用：创建Chart示例创建chart：
# 默认示例中部署的是一个nginx服务 helm create mychart 打包chart：
helm package mychart • charts：目录里存放这个chart依赖的所有子chart。
• Chart.yaml：用于描述这个 Chart的基本信息，包括名字、描述信息以及版本等。
• values.yaml ：用于存储 templates 目录中模板文件中用到变量的值。
• Templates： 目录里面存放所有yaml模板文件。</description>
    </item>
    
    <item>
      <title>Git使用方法</title>
      <link>http://example.org/post/git/</link>
      <pubDate>Mon, 15 Aug 2022 08:15:16 +0000</pubDate>
      
      <guid>http://example.org/post/git/</guid>
      <description>GitGit 是一个开源的分布式版本控制软件,用以有效、高速的处理从很小到非常大的项目版本管理。 Git 最初是由Linus Torvalds设计开发的，用于管理Linux内核开发。Git 是根据GNU通用公共许可证版本2的条款分发的自由/免费软件，安装参见：http://git-scm.com/
打开git bash，初始化配置git config --global user.name &amp;#34;wandong&amp;#34; git config --global user.email &amp;#34;993696910@qq.com&amp;#34; # 对已存在的目录进行git的初始化 git init # 添加远程仓库地址 git remote add origin http://git.cqzwymgmt.com/root/gin-project-orm.git # git add . git commit -m &amp;#34;Initial commit&amp;#34; # 推送到远程仓库 master分支 git push -u origin master 在新的环境拉取代码，进行开发git clone http://git.cqzwymgmt.com/root/gin-project-orm.git # 创建新的分支继续开发 git branch dev # 列出所有分支 git branch # 切换分支 git checkout dev # 可以开始开发新功能了，尽量开发新的文件，避免合并的时候出现冲突进而解决冲突。 git add . git commit -m &amp;#34;change log function&amp;#34; # 推送到远程仓库 dev分支 git push -u origin dev 更新本地代码# 拉取最新的dev分支代码，如果本地没有该分支，先创建 git branch dev # 使用pull命令更新分支代码的时候，要先处于该分支，不然会被合并 git branch dev git checkout dev git pull origin dev # 查看dev分支代码和master代码区别 将dev分支合并到master分支 git merge dev # 或者 git rebase dev 删除本地和远程仓库的分支# 删除分支前先切换其他分支 git branch -d dev git push origin --delete dev </description>
    </item>
    
    <item>
      <title>Golang学习笔记</title>
      <link>http://example.org/post/golang/</link>
      <pubDate>Mon, 15 Aug 2022 08:15:16 +0000</pubDate>
      
      <guid>http://example.org/post/golang/</guid>
      <description>推荐博客 https://www.liwenzhou.com/posts/Go/golang-menu/
Linux 安装go语言环境# 下载地址 https://golang.google.cn/dl/ tar -xvzf go1.17.11.linux-386.tar.gz -C /usr/local yum install glibc.i686 -y mkdir -p /root/workspace cat &amp;lt;&amp;lt;EOF &amp;gt;&amp;gt; /etc/profile export PATH=$PATH:/usr/local/go/bin export GOPATH=&amp;#34;$HOME/workspace&amp;#34; EOF source /etc/profile #设置国内代理 go env -w GOPROXY=https://goproxy.cn,direct #查看go env go env Linux下创建一个go项目#查看GOPATH go env | grep -i gopath #GOPATH=&amp;#34;/root/workspace&amp;#34; cd /root/workspace;mkdir {src,bin,pkg} #进入src目录创建项目 cd src &amp;amp;&amp;amp; mkdir GoRedis #随后编写main.go文件 构建多平台运行代码go env -w GOOS=linux go env -w GOARCH=amd64 go build go env -w GOOS=windwos go env -w GOARCH=amd64 go build main.</description>
    </item>
    
    <item>
      <title>golang定时任务系统</title>
      <link>http://example.org/post/golang%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Mon, 15 Aug 2022 08:15:16 +0000</pubDate>
      
      <guid>http://example.org/post/golang%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F/</guid>
      <description>golang定时任务系统项目地址： https://github.com/ouqiang/gocron/releases 部署方法https://github.com/ouqiang/gocron/releases/download/v1.5.3/gocron-node-v1.5.3-linux-amd64.tar.gz
https://github.com/ouqiang/gocron/releases/download/v1.5.3/gocron-v1.5.3-linux-amd64.tar.gz
项目分为两个包 gocron-node和gocron，gocron-node为任务节点，实际执行任务，gocron为web端
创建gocron用户useradd gocron 解压软件包并运行tar -xvzf gocron-node-v1.5.3-linux-amd64.tar.gz -C /home/gocron tar -xvzf gocron-v1.5.3-linux-amd64.tar.gz -C /home/gocron # 修改权限 chown gocron:gocron -R /home/gocron/ # 运行gocron web端 前台运行，监听5920端口 cd /home/gocron/gocron-linux-amd64 &amp;amp;&amp;amp; su gocron &amp;amp;&amp;amp; ./gocron web # 新起窗口运行gocron node任务节点 前台运行 cd /home/gocron/gocron-node-linux-amd64 su gocron &amp;amp;&amp;amp; ./gocron-node 1、登录web页面，访问 http://localhost:5920
2、初始化数据库，并创建登录用户，注意数据库要单独使用新库，不能有其他表
3、然后登录，添加任务节点，添加完成后测试连接
![image-20220721155135950](D:\typora Note\assets\image-20220721155135950.png)
4、进入系统管理配置通知配置
使用钉钉webhook进行通知
![image-20220721155256643](D:\typora Note\assets\image-20220721155256643.png)
模板文件写法：
{ &amp;#34;at&amp;#34;: { &amp;#34;atMobiles&amp;#34;: [ &amp;#34;&amp;#34; ], &amp;#34;atUserIds&amp;#34;: [ &amp;#34;user123&amp;#34; ], &amp;#34;isAtAll&amp;#34;: &amp;#34;false&amp;#34; }, &amp;#34;text&amp;#34;: { &amp;#34;content&amp;#34;: &amp;#34;任务ID: {{.</description>
    </item>
    
    <item>
      <title>golang微服务</title>
      <link>http://example.org/post/golang%E5%BE%AE%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Mon, 15 Aug 2022 08:15:16 +0000</pubDate>
      
      <guid>http://example.org/post/golang%E5%BE%AE%E6%9C%8D%E5%8A%A1/</guid>
      <description>golang微服务1、RPC 简介⚫ 远程过程调用（Remote Procedure Call，RPC）是一个计算机通信协议
⚫ 该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额 外地为这个交互作用编程
⚫ 如果涉及的软件采用面向对象编程，那么远程过程调用亦可称作远程调用或远程方 法调用
2、golang中如何实现RPC⚫ golang 中实现 RPC 非常简单，官方提供了封装好的库，还有一些第三方的库
⚫ golang 官方的 net/rpc 库使用 encoding/gob 进行编解码，支持 tcp 和 http 数据传输方 式，由于其他语言不支持 gob 编解码方式，所以 golang 的 RPC 只支持 golang 开发 的服务器与客户端之间的交互
⚫ 官方还提供了 net/rpc/jsonrpc 库实现 RPC 方法，jsonrpc 采用 JSON 进行数据编解码， 因而支持跨语言调用，目前 jsonrpc 库是基于 tcp 协议实现的，暂不支持 http 传输 方式
⚫ golang 的 RPC 必须符合 4 个条件才可以
​	◼ 结构体字段首字母要大写，要跨域访问，所以大写
​	◼ 函数名必须首字母大写（可以序列号导出的）
​	◼ 函数第一个参数是接收参数，第二个参数是返回给客户端参数，必须是指针类 型</description>
    </item>
    
    <item>
      <title>golang日志框架zap</title>
      <link>http://example.org/post/golang%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6zap/</link>
      <pubDate>Mon, 15 Aug 2022 08:15:16 +0000</pubDate>
      
      <guid>http://example.org/post/golang%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6zap/</guid>
      <description>golang日志框架zappackage main import ( &amp;#34;go.uber.org/zap&amp;#34; &amp;#34;go.uber.org/zap/zapcore&amp;#34; &amp;#34;os&amp;#34; ) var logger *zap.Logger var sugarLogger *zap.SugaredLogger func InitLogger() { writeSyncer := getLogWriter() encoder := getEncoder() core := zapcore.NewCore(encoder, writeSyncer, zapcore.DebugLevel) logger = zap.New(core) sugarLogger = logger.Sugar() } func getEncoder() zapcore.Encoder { encoderConfig := zap.NewProductionEncoderConfig() encoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder encoderConfig.EncodeLevel = zapcore.CapitalLevelEncoder return zapcore.NewJSONEncoder(encoderConfig) } func getLogWriter() zapcore.WriteSyncer { file, _ := os.Create(&amp;#34;./test.log&amp;#34;) return zapcore.AddSync(file) } func main() { InitLogger() defer logger.Sync() defer sugarLogger.Sync() logger.</description>
    </item>
    
    <item>
      <title>jdk安装教程（容器）</title>
      <link>http://example.org/post/jdk%E5%AE%89%E8%A3%85/</link>
      <pubDate>Mon, 15 Aug 2022 08:15:16 +0000</pubDate>
      
      <guid>http://example.org/post/jdk%E5%AE%89%E8%A3%85/</guid>
      <description>jdk安装dockerfile文件
下载地址：https://www.oracle.com/java/technologies/downloads/#java8 jdk-8u341-linux-x64.tar.gz文件
FROM ubuntu:latest ADD jdk-8u341-linux-x64.tar.gz /usr/local/ RUN mv /usr/local/jdk1.8.0_341 /usr/local/jdk1.8 ENV JAVA_HOME=/usr/local/jdk1.8 ENV JRE_HOME=${JAVA_HOME}/jre ENV CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib:$CLASSPATH ENV JAVA_PATH=${JAVA_HOME}/bin:${JRE_HOME}/bin ENV PATH=$PATH:${JAVA_PATH} RUN apt-get update &amp;amp;&amp;amp; apt-get install curl tree iputils-ping net-tools iproute2 vim -y CMD [&amp;#34;java&amp;#34;,&amp;#34;-version&amp;#34;] </description>
    </item>
    
    <item>
      <title>jenkins构建go项目</title>
      <link>http://example.org/post/jenkins%E6%9E%84%E5%BB%BAgo%E9%A1%B9%E7%9B%AE/</link>
      <pubDate>Mon, 15 Aug 2022 08:15:16 +0000</pubDate>
      
      <guid>http://example.org/post/jenkins%E6%9E%84%E5%BB%BAgo%E9%A1%B9%E7%9B%AE/</guid>
      <description>jenkins构建go项目一、配置jenkins1、全局工具配置将go安装包解压后，拷贝至以上的安装目录
自由风格构建，选go的构建环境，然后就可以在shell中执行go命令了</description>
    </item>
    
    <item>
      <title>ElasticSearch快速入门实战</title>
      <link>http://example.org/post/elasticsearch/</link>
      <pubDate>Sun, 15 Aug 2021 08:15:16 +0000</pubDate>
      
      <guid>http://example.org/post/elasticsearch/</guid>
      <description>ElasticSearch快速入门实战 主讲老师：Fox
ES版本： v7.17.3
ES环境搭建视频：https://pan.baidu.com/s/1PsTNbpDy&amp;ndash;M-pvFWb3aehQ?pwd=nwxl
​ 文档：1.ElasticSearch快速入门实战.note 链接：http://note.youdao.com/noteshare?id=d5d5718ae542f274ba0fda4284a53231&amp;amp;sub=68E590656C7A48858C7F6997D4A1511A
全文检索数据分类：
结构化数据： 固定格式，有限长度 比如mysql存的数据 非结构化数据：不定长，无固定格式 比如邮件，word文档，日志 半结构化数据： 前两者结合 比如xml，html 搜索分类：
结构化数据搜索： 使用关系型数据库
非结构化数据搜索
顺序扫描 全文检索 设想一个关于搜索的场景，假设我们要搜索一首诗句内容中带“前”字的古诗
name content author 静夜思 床前明月光,疑是地上霜。举头望明月，低头思故乡。 李白 望庐山瀑布 日照香炉生紫烟，遥看瀑布挂前川。飞流直下三千尺,疑是银河落九天。 李白 &amp;hellip; &amp;hellip; &amp;hellip; 思考：用传统关系型数据库和ES 实现会有什么差别？
如果用像 MySQL 这样的 RDBMS 来存储古诗的话，我们应该会去使用这样的 SQL 去查询
​ select name from poems where content like &amp;ldquo;%前%&amp;rdquo;
这种我们称为顺序扫描法，需要遍历所有的记录进行匹配。不但效率低，而且不符合我们搜索时的期望，比如我们在搜索“ABCD&amp;quot;这样的关键词时，通常还希望看到&amp;quot;A&amp;quot;,&amp;ldquo;AB&amp;rdquo;,&amp;ldquo;CD&amp;rdquo;,“ABC”的搜索结果。
什么是全文检索全文检索是指：
通过一个程序扫描文本中的每一个单词，针对单词建立索引，并保存该单词在文本中的位置、以及出现的次数 用户查询时，通过之前建立好的索引来查询，将索引中单词对应的文本位置、出现的次数返回给用户，因为有了具体文本的位置，所以就可以将具体内容读取出来了 ​ 搜索原理简单概括的话可以分为这么几步：
内容爬取，停顿词过滤比如一些无用的像&amp;quot;的&amp;quot;，“了”之类的语气词/连接词 内容分词，提取关键词 根据关键词建立倒排索引 用户输入关键词进行搜索 倒排索引索引就类似于目录，平时我们使用的都是索引，都是通过主键定位到某条数据，那么倒排索引呢，刚好相反，数据对应到主键。
​ 这里以一个博客文章的内容为例:
正排索引（正向索引） 文章ID 文章标题 文章内容 1 浅析JAVA设计模式 JAVA设计模式是每一个JAVA程序员都应该掌握的进阶知识 2 JAVA多线程设计模式 JAVA多线程与设计模式结合 倒排索引（反向索引）</description>
    </item>
    
    <item>
      <title>离线安装docker</title>
      <link>http://example.org/post/elasticsearch%E5%85%A5%E9%97%A8/</link>
      <pubDate>Sun, 15 Aug 2021 08:15:16 +0000</pubDate>
      
      <guid>http://example.org/post/elasticsearch%E5%85%A5%E9%97%A8/</guid>
      <description>ES版本： v7.17.3
ES环境搭建视频：https://pan.baidu.com/s/1PsTNbpDy&amp;ndash;M-pvFWb3aehQ?pwd=nwxl
ElasticSearch快速入门实战note 链接：http://note.youdao.com/noteshare?id=d5d5718ae542f274ba0fda4284a53231&amp;amp;sub=68E590656C7A48858C7F6997D4A1511A
全文检索数据分类：
结构化数据： 固定格式，有限长度 比如mysql存的数据 非结构化数据：不定长，无固定格式 比如邮件，word文档，日志 半结构化数据： 前两者结合 比如xml，html 搜索分类：
结构化数据搜索： 使用关系型数据库
非结构化数据搜索
顺序扫描 全文检索 设想一个关于搜索的场景，假设我们要搜索一首诗句内容中带“前”字的古诗
name content author 静夜思 床前明月光,疑是地上霜。举头望明月，低头思故乡。 李白 望庐山瀑布 日照香炉生紫烟，遥看瀑布挂前川。飞流直下三千尺,疑是银河落九天。 李白 &amp;hellip; &amp;hellip; &amp;hellip; 思考：用传统关系型数据库和ES 实现会有什么差别？
如果用像 MySQL 这样的 RDBMS 来存储古诗的话，我们应该会去使用这样的 SQL 去查询
​ select name from poems where content like &amp;ldquo;%前%&amp;rdquo;
这种我们称为顺序扫描法，需要遍历所有的记录进行匹配。不但效率低，而且不符合我们搜索时的期望，比如我们在搜索“ABCD&amp;quot;这样的关键词时，通常还希望看到&amp;quot;A&amp;quot;,&amp;ldquo;AB&amp;rdquo;,&amp;ldquo;CD&amp;rdquo;,“ABC”的搜索结果。
什么是全文检索全文检索是指：
通过一个程序扫描文本中的每一个单词，针对单词建立索引，并保存该单词在文本中的位置、以及出现的次数 用户查询时，通过之前建立好的索引来查询，将索引中单词对应的文本位置、出现的次数返回给用户，因为有了具体文本的位置，所以就可以将具体内容读取出来了 ​ 搜索原理简单概括的话可以分为这么几步：
内容爬取，停顿词过滤比如一些无用的像&amp;quot;的&amp;quot;，“了”之类的语气词/连接词 内容分词，提取关键词 根据关键词建立倒排索引 用户输入关键词进行搜索 倒排索引索引就类似于目录，平时我们使用的都是索引，都是通过主键定位到某条数据，那么倒排索引呢，刚好相反，数据对应到主键。
​ 这里以一个博客文章的内容为例:
正排索引（正向索引）
文章ID 文章标题 文章内容 1 浅析JAVA设计模式 JAVA设计模式是每一个JAVA程序员都应该掌握的进阶知识 2 JAVA多线程设计模式 JAVA多线程与设计模式结合 倒排索引（反向索引）</description>
    </item>
    
    <item>
      <title>离线安装docker</title>
      <link>http://example.org/post/%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/</link>
      <pubDate>Sun, 15 Aug 2021 08:15:16 +0000</pubDate>
      
      <guid>http://example.org/post/%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/</guid>
      <description>离线安装dockerhttps://download.docker.com/linux/static/stable/x86_64/docker-20.10.14.tgz
#解压 tar -xvzf docker-20.10.14.tgz -C /opt/ chown root:root -R /opt/docker/ cp /opt/docker/* /usr/bin cat &amp;lt;&amp;lt;EOF &amp;gt;/etc/systemd/system/docker.service [Unit] Description=Docker Application Container Engine Documentation=https://docs.docker.com After=network-online.target firewalld.service Wants=network-online.target [Service] Type=notify ExecStart=/usr/bin/dockerd ExecReload=/bin/kill -s HUP \$MAINPID LimitNOFILE=infinity LimitNPROC=infinity TimeoutStartSec=0 Delegate=yes KillMode=process Restart=on-failure StartLimitBurst=3 StartLimitInterval=60s [Install] WantedBy=multi-user.target EOF chmod +x /etc/systemd/system/docker.service # 加载service配置 systemctl daemon-reload #设置开机启动 并立即启动 systemctl enable docker.service --now </description>
    </item>
    
    <item>
      <title>about</title>
      <link>http://example.org/about/</link>
      <pubDate>Sun, 25 Oct 2015 08:36:54 -0700</pubDate>
      
      <guid>http://example.org/about/</guid>
      <description>正文内容</description>
    </item>
    
    <item>
      <title>Hello World</title>
      <link>http://example.org/post/hello-world/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/post/hello-world/</guid>
      <description>Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.
Quick StartCreate a new post$ hexo new &amp;#34;My New Post&amp;#34; More info: Writing
Run server$ hexo server More info: Server
Generate static files$ hexo generate More info: Generating
Deploy to remote sites$ hexo deploy More info: Deployment</description>
    </item>
    
    <item>
      <title>hexo博客框架的使用</title>
      <link>http://example.org/post/hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/post/hexo%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>hexo博客框架的使用安装node.js官网： https://nodejs.org/en/
安装国内淘宝npmnpm install -g cnpm --registry=https://registry.npm.taobao.org 安装hexocnpm install -g hexo-clihexo -v hexo初始化hexo init 目录 hexo server 新建文章 文章都在source\_posts目录下
hexo new &amp;#34;我的第一篇博客文章&amp;#34; 配置后刷新并重启服务hexo clean hexo g hexo server 更换主题进入项目目录
git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 修改项目目录下配置文件_config.yml
theme: yilia 修复更换主题后全部文章无法显示问题# 进入项目目录后 cnpm i hexo-generator-json-content --save # 随后在项目目录下的_config.yml文件后添加内容 jsonContent: meta: false pages: false posts: title: true date: true path: true text: false raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true 刷新并重启项目</description>
    </item>
    
    <item>
      <title>rancher的安装和使用</title>
      <link>http://example.org/post/rancher/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/post/rancher/</guid>
      <description>RancherRancher 是一套容器管理平台，它可以帮助组织在生产环境中轻松快捷的部署和管理容器。 Rancher 可以轻松地管理各种环境的 Kubernetes，满足 IT 需求并为 DevOps 团队提供支持。
Rancher 四个组成部分Rancher 由以下四个部分组成：
1、基础设施编排
Rancher 可以使用任何公有云或者私有云的 Linux 主机资源。Linux 主机可以是虚拟机，也可以是 物理机。
2、容器编排与调度
很多用户都会选择使用容器编排调度框架来运行容器化应用。Rancher 包含了当前全部主流的编排 调度引擎，例如 Docker Swarm， Kubernetes， 和 Mesos。同一个用户可以创建 Swarm 或者 Kubernetes 集群。并且可以使用原生的 Swarm 或者 Kubernetes 工具管理应用。 除了 Swarm，Kubernetes 和 Mesos 之外，Rancher 还支持自己的 Cattle 容器编排调度引擎。 Cattle 被广泛用于编排 Rancher 自己的基础设施服务以及用于 Swarm 集群，Kubernetes 集群和 Mesos 集群的配置，管理与升级。
3、应用商店
Rancher 的用户可以在应用商店里一键部署由多个容器组成的应用。用户可以管理这个部署的应 用，并且可以在这个应用有新的可用版本时进行自动化的升级。Rancher 提供了一个由 Rancher 社区维 护的应用商店，其中包括了一系列的流行应用。Rancher 的用户也可以创建自己的私有应用商店。
4、企业级权限管理
Rancher 支持灵活的插件式的用户认证。支持 Active Directory，LDAP， Github 等 认证方 式。</description>
    </item>
    
    <item>
      <title>zookeeper的安装和使用</title>
      <link>http://example.org/post/zookeeper/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/post/zookeeper/</guid>
      <description>zookeeper官网 https://zookeeper.apache.org/ 找download
一、下载软件包https://dlcdn.apache.org/zookeeper/zookeeper-3.8.0/apache-zookeeper-3.8.0-bin.tar.gz
二、集群部署1、安装JDKcentos
yum install java-1.8.0-openjdk* -y 2、zk配置文件# The number of milliseconds of each ticktickTime=2000# The number of ticks that the initial # synchronization phase can takeinitLimit=10# The number of ticks that can pass between # sending a request and getting an acknowledgementsyncLimit=5# the directory where the snapshot is stored.# do not use /tmp for storage, /tmp here is just # example sakes.</description>
    </item>
    
    <item>
      <title>随笔</title>
      <link>http://example.org/post/%E9%9A%8F%E7%AC%94/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/post/%E9%9A%8F%E7%AC%94/</guid>
      <description>随笔技术的变革，一定是思想先行，云原生是一种构建和运行应用程序的方法，是一套技术体系和方法论。云原生（CloudNative）是一个组合词，Cloud+Native。Cloud表示应用程序位于云中，而不是传统的数据中心；Native表示应用程序从设计之初即考虑到云的环境，原生为云而设计，在云上以最佳姿势运行，充分利用和发挥云平台的弹性+分布式优势。
符合云原生架构的应用程序应该是：采用开源堆栈（K8S+Docker）进行容器化，基于微服务架构提高灵活性和可维护性，借助敏捷方法、DevOps支持持续迭代和运维自动化，利用云平台设施实现弹性伸缩、动态调度、优化资源利用率。
云原生的四要素微服务：几乎每个云原生的定义都包含微服务，跟微服务相对的是单体应用，微服务有理论基础，那就是康威定律，指导服务怎么切分，很玄乎，凡是能称为理论定律的都简单明白不了，不然就忒没b格，大概意思是组织架构决定产品形态，不知道跟马克思的生产关系影响生产力有无关系。
微服务架构的好处就是按function切了之后，服务解耦，内聚更强，变更更易；另一个划分服务的技巧据说是依据DDD来搞。
容器化：Docker是应用最为广泛的容器引擎，在思科谷歌等公司的基础设施中大量使用，是基于LXC技术搞的，容器化为微服务提供实施保障，起到应用隔离作用，K8S是容器编排系统，用于容器管理，容器间的负载均衡，谷歌搞的，Docker和K8S都采用Go编写，都是好东西。
DevOps：这是个组合词，Dev+Ops，就是开发和运维合体，不像开发和产品，经常刀刃相见，实际上DevOps应该还包括测试，DevOps是一个敏捷思维，是一个沟通文化，也是组织形式，为云原生提供持续交付能力。
持续交付：持续交付是不误时开发，不停机更新，小步快跑，反传统瀑布式开发模型，这要求开发版本和稳定版本并存，其实需要很多流程和工具支撑。
如何云原生？首先，云原生借了云计算的东风，没有云计算，自然没有云原生，云计算是云原生的基础。
随着虚拟化技术的成熟和分布式框架的普及，在容器技术、可持续交付、编排系统等开源社区的推动下，以及微服务等开发理念的带动下，应用上云已经是不可逆转的趋势。
云计算的3层划分，即基础设施即服务(IaaS)、平台即服务(PaaS)、软件即服务(SaaS)为云原生提供了技术基础和方向指引，真正的云化不仅仅是基础设施和平台的变化，应用也需要做出改变，摈弃传统的土方法，在架构设计、开发方式、部署维护等各个阶段和方面都基于云的特点，重新设计，从而建设全新的云化的应用，即云原生应用。
1.本地部署的传统应用往往采用c/c++、企业级java编写，而云原生应用则需要用以网络为中心的go、node.js等新兴语言编写。
2.本地部署的传统应用可能需要停机更新，而云原生应用应该始终是最新的，需要支持频繁变更，持续交付，蓝绿部署。
3.本地部署的传统应用无法动态扩展，往往需要冗余资源以抵抗流量高峰，而云原生应用利用云的弹性自动伸缩，通过共享降本增效。
4.本地部署的传统应用对网络资源，比如ip、端口等有依赖，甚至是硬编码，而云原生应用对网络和存储都没有这种限制。
5.本地部署的传统应用通常人肉部署手工运维，而云原生应用这一切都是自动化的。
6.本地部署的传统应用通常依赖系统环境，而云原生应用不会硬连接到任何系统环境，而是依赖抽象的基础架构，从而获得良好移植性。
7.本地部署的传统应用有些是单体(巨石)应用，或者强依赖，而基于微服务架构的云原生应用，纵向划分服务，模块化更合理。
可见，要转向云原生应用需要以新的云原生方法开展工作，云原生包括很多方面：基础架构服务、虚拟化、容器化、容器编排、微服务。幸运的是，开源社区在云原生应用方面做出了大量卓有成效的工作，很多开源的框架和设施可以通过拿来主义直接用，2013年Docker推出并很快成为容器事实标准，随后围绕容器编排的混战中，2017年诞生的k8s很快脱颖而出，而这些技术极大的降低了开发云原生应用的技术门槛。</description>
    </item>
    
  </channel>
</rss>
